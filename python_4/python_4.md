## 4.1 class構文
### クラス定義
- クラスを定義するには **`class`** を使用する。
  - クラスメソッドの第1引数に`self`がある
    -  `self`はこのクラスがインスタンス化されたオブジェクトが渡される。
- 例：class_pra.py

### インスタンス化
- クラスを使うには**インスタンス化**する。
  - クラス名に **`()`** を付けて呼び出すと、新たなインスタンスが生成される。
- 例：  instance.py

### selfとは
- メソッドの第１引数に宣言する **`self`** は**インスタンス自体**を表す。
  - また、メソッド呼び出しの時は**インスタンスが暗黙的に第１引数**として、**それ以降の引数が実引数**として渡される。
    - **instance.py**の例として`user1.start_name()` を実行すると、`user1` インスタンスの`start_name(self)` が実行され、`self`に`user1` が入る。
        - それにより`self.name`は`user1`の`name`属性の値となり、`start_name()` は`user1`の`name`属性の１文字目を返す。

## 4.2 属性とメソッド
### コンストラクター
- クラスをインスタンス化するときはコンストラクターが呼ばれる。
    - コンストラクターメソッドは‘ **`__init__`** であり、このメソッドを定義することで、**初期化の挙動**を決めることができる。
        - **`__init__`** メソッドには初期化に使う**仮引数**を定義
            - その引数をもとにインスタンスのデータ属性にデータを設定する
- 例：constructor.py

### データ属性

- データ属性は**値を格納**する場所
    - データ属性には**クラス変数**と**インスタンス変数**が存在する。
        - 先ほど定義した`User`クラスには`user_type` という１つの**クラス変数**が定義されている。
            - このクラス変数には初期値が設定されている。
    - メソッドでデータの更新が行われたり、使われたりする。
- インスタンス変数はメソッド内で「**`self.属性名 = 値`**」のような形で新たな変数が定義でき、
インスタンス内で参照したり上書きしたりできる。
    - 具体的には **`__init__`** メソッド内で「`self.name = name`」と定義している。
    - インスタンス変数はインスタンス化したオブジェクトに対して
    「**ドット（`.`）**」に続けたインスタンス変数名でアクセスできる。
- 例：constructor.py

### メソッド

- メソッドは関数のように使われるものであり、３種類のメソッドが存在する。
1. **インスタンスメソッド**
    - インスタンス化されたクラスに対して実行されるメソッド
        - クラス内で動作するように、第１引数に`self`が渡され、
        インスタンス化されたクラスの属性やメソッドを使うことができる。
    - インスタンスメソッドの実行はインスタンス化したオブジェクトに対して、
    「ドット（`.`）」に続けた「**`メソッド名()`**」で実行可能。     
2. **クラスメソッド**
    - クラスオブジェクトを暗黙的に第１引数をとる、特別なメソッド。
    - **`@classmethod`** デコレーターをメソッドに使うことで定義する。
    - 外部の情報に依存したインスタンスを生成する場合などの特殊なインスタンス化に使われる。
3. **静的メソッド**
    - インスタンス化せずに使うことを前提としたメソッド
    - **`@staticmethod`** デコレーターをメソッドに使うことで定義する。
    - 静的メソッドでは暗黙的な引数渡しが行われない。
        - よって、クラスオブジェクトやインスタンスオブジェクトをメソッド内で使用しない。
    - インスタンス変数に依存しないけど、機能をひとまとまりにするためにクラスに静的メソッドを宣言する場合がある。
        - ただし、Pythonではそこまで多くない。
- 例：method.py
#### 特殊メソッド
- 特殊メソッドでは関数が実行された時の挙動や演算子の挙動を決めることができる。
  - この特殊メソッドはメソッド名の前後に **アンダースコア（`_`）** を２個付けたもの
  - **`__init__`** も特殊メソッドの一つ。
##### 関数による挙動
- オブジェクトを **`print`** 関数で出力したときの文字列表現は **`__repr__()`** 特殊メソッドで変更できる。
- 組み込み関数 **`len()`** は引数に与えたオブジェクトの **`__len__()`** メソッドが呼び出され、文字数やリストの要素数を取得できる。
  - よって、子の挙動は **`__len__()`** メソッドで変更できる。
    - **`__len__()`** メソッドがないクラスのインスタンスを、**`len()`** 関数に渡すと **`TypeError`** が発生する。

##### 演算子による挙動
- 足し算で使う演算子（`＋`）の挙動には **`__add__`** という**特殊メソッド**が呼び出される。
    - 演算子の挙動も特殊メソッドで決まる。
    - **`==`** では **`__eq__`** メソッドが呼び出される。
- 例： special_method.py

##### プロパティ化
- **インスタンスメソッド** を **プロパティ化** すると、カッコを付けずにデータ属性のようにアクセスできる
- **`@property` デコレーター**を使いプロパティ化したメソッドはデータ属性のように取り扱うことができる。
    - プロパティ化することで、**`getter`**メソッドだけでなく、**`setter`や`deleter`メソッドを明示的に設定**できる。
- 例： property.py

## 4.3 継承

### 標準ライブラリの継承の例

- Pythonの標準ライブラリにも継承が使われている。
    - **`pathilib`ライブラリ**はOSごとに異なるファイルシステムのパスを基本的に同じインタフェースで操作できるようになっているライブラリ。
        - このライブラリの基底クラスは、**`PuerPath`** というもの。
        - この基底クラスから継承した、Windows用の **`PureWindowsPath`** とWindows以外向けの **`PurePosixPath`** がある。

**親クラスと子クラス**

- 継承関係にある継承クラスは、基底クラスのデータ属性やメソッドをすべて引き継ぐ。
    - 基底クラスを「親クラス」継承クラスを「子クラス」という
- 共通するデータ属性やメソッド定義を親クラスの１か所に集約できる。
    - 子クラスに特化した機能のみを子クラスで定義できる。

### 子クラスの定義
- 独自に定義したクラスやライブラリの既存クラスを親クラスとして継承した、新たなクラスを定義できる。
    - 子クラスに必要な範囲のみを実装することで、少ないコード量で目的の機能を実現できる。

**例：定義方法**
```python
class 子クラス名(親クラス名):
    属性 = 値

    def メソッド名(self):
        メソッドの処理
```
- 属性を定義する場合、親クラスに存在する属性は値が上書きされ、親クラスに存在しない属性は子クラスにのみ存在する新たな属性となる。メソッドも同様。

- 例：child_class.py
  - 例の **`setUp`メソッド**は親クラスの`unittest.TestCase` に定義されている**テストの初期化処理を行うメソッド**
    - これは今回のクラス用に上書き
- 子クラス用のメソッドとして **`test_upper`** を定義

**`super()` 関数**
- 子クラスでメソッドを上書きする際に、親クラスに実装されているメソッドも実行したい場合がある。
- 例：class_super.py
  - 例では **`unittest.TestCase`** クラスを継承した **`TestBase`** クラスを宣言し、
共通で使う **`setUp()`** メソッドと、**`tearDown()`** メソッドを宣言する。
- **`super`**  は組み込み関数で、親クラスを代理オブジェクトとして返す関数で、継承元である親クラスのメソッドを実行するために利用する。
### 多重継承
- pythonは親クラスを持つ**多重継承をサポート**している。
- 多重継承の場合は、クラス定義でカッコ内に複数の親クラスを示す。
- 例：
```python
class Custom(Base1, Base2):
    pass
```

## 4.4 dataclass
### 基本文法

- **例：定義方法**

```python
from dataclasses import dataclass

# クラスデコレーターでdataclassを宣言
@dataclass
class User:
    # クラス変数を宣言、型ヒントを宣言
    name: str
    age: int
    address: str
```

- `dataclasses`から`dataclass` をインポートする。
- クラスデコレーターを用いてクラスを宣言し、次にクラス属性を宣言する。
- 宣言の際に型ヒントを使う。
    - 型ヒントを使うことでデータ構造が見やすくなる。
- この **`dataclass`** 宣言で、コンストラクターのメソッドである **`__init__`** や
特殊メソッドである、**`__repr__`** などが自動的に定義される。
- つまり以下のようにclassを宣言した場合と同等

```python
class User:
    # コンストラクターメソッド
    def __init__(self, name, age, address):
        # インスタンス変数name、age、addressにコンストラクター引数の値を代入
        self.name = name
        self.age = age
        self.address = address
       
     # __repr__メソッドを追加
    def __repr__(self):
        return F"User(name='{self.name}',age={self.age}, address='{self.address}')"
```

**`dataclass`デコレーターの引数**

- **`dataclass`** デコレーターに引数を与えて挙動を変えることができる。
- 例：dataclass.py
  - 例で設定した **`frozen=True`** は**イミュータブル（タプルのような変更不可の）オブジェクト**が求められる場合で利用する。
 
### コンストラクターの任意引数
- コンストラクターに渡す引数を任意にし、デフォルト値を決めたい場合は以下のように定義

```python
from dataclasses import dataclass

# クラスデコレーターでdataclassを宣言
@dataclass
class User2:
    # クラス変数を宣言、型ヒントを宣言
    name: str
    age: int
    address: str
    # デフォルト値を設定。デフォルト値を持つ属性は最後に宣言
    active: bool = False
```

- デフォルト値を設定する場合は、**デフォルト値を持たない属性よりも下に宣言する**必要がある
    - これは、関数の引数にデフォルト値を設定する場合と同様。
- これは下記と同等。
```python
class User2:
    # コンストラクターメソッド
    def __init__(self, name, age, address):
        # インスタンス変数name、age、addressにコンストラクター引数の値を代入
        self.name = name
        self.age = age
        self.address = address
        self.active = active
```
#### データ変換
- **`dataclasses`** で宣言したクラスは、辞書やタプルに変換する仕組みがある。
  - **`asdict(instance)`** ：**辞書**に変換
  - **`astuple(instance)`** ：**タプル**に変換
- 例：dataclass_change.py

## 4.5 オブジェクト関連関数

### 関数の種類

##### **`id()`関数**
- オブジェクトの識別子である`id`を整数で返す関数。
    - 同一のオブジェクトは識別子が同じになる
- 例：obj_func.py

##### **`type()`関数**
- オブジェクトの種類を返したり、新たな型を返す。
  - オブジェクトの種類を返すには、**`type()`** 関数の引数にオブジェクトを1つ渡す。
- 例：obj_func.py

##### **`isinstance()`** 関数
- オブジェクトの型チェックを行う関数
  - 第１引数に**チェック対象のオブジェクト**
  - 第２引数に**チェックしたいデータ型**
  - 戻り値は **`bool`**
- 例：obj_func.py

##### **`issubclass()`関数**
- データ型に**継承関係があるか**を確認する関数
    - 第１引数に**チェック対象のデータ型であるクラス**を渡し、第２引数に**継承元のデータ型**を渡す
- 例：obj_func.py

##### **`help()`関数**
- オブジェクトのヘルプを表示する
  - 独自の関数やクラスを定義した場合に、 **`docstring`** があると **`help()`** で確認できる
- 例：obj_func.py

##### **`dir()`関数**
- オブジェクトが持つメソッドやデータ属性を確認
  - オブジェクトが持つメソッドの確認時に便利
- 例：obj_func.py