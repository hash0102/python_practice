## 16.1 対話的な実行例をテストする **`doctest`**

- **`doctest`** は、Pythonの標準ライブラリの一つで、**関数のドキュメント文字列（docstring）に書かれたサンプルコードを実行し、その出力が期待される出力と一致するかをテストする**ためのモジュール。
    - これにより、ドキュメントが常に最新かつ正確であることを保証し、コードの例がそのままテストとしても機能するようになる。

### `doctest`を作成する

- `doctest`の作成は非常にシンプル
- テストしたい関数のドキュメント文字列内に、**Pythonのインタラクティブシェル（REPL）のセッションを模倣した形式でテストケースを記述するだけ**

- **ドキュメント文字列の形式**
    - Pythonのインタラクティブシェルで**入力するコードを`>>>` で始める**
        - その直後に**期待される出力結果を記述**する

```python
def my_function(x):
    """
    この関数は引数に1を加算して返します。

    >>> my_function(2)
    3
    >>> my_function(0)
    1
    """
    return x + 1
```

**注意点**
- `>>>` の後に続くコードは、**`doctest`が実行するPythonコード**
  - 期待される出力は、**正確に記述する必要がある**
  - スペースや改行、引用符の種類（シングルクォート `'`とダブルクォート `"`）まで一致している必要がある
  - 出力がない場合は、何も記述しない
- 複数行にわたるコードは、**最初の行だけを`>>>` で始め、以降の行は`...`** で始める。

**テストの実行方法**
- 作成した`doctest`を実行するには、主に以下の2つの方法がある

1. **コマンドラインから実行する**
   - ファイル名を`doctest`モジュールに渡して実行

```python
python -m doctest your_file.py
```

- このコマンドは、テストが失敗した場合にのみ詳細な出力を表示する
- 成功した場合は、何も出力されない

2. **スクリプト内で実行する**
   - テスト対象のPythonスクリプト内に以下を追加し
``` python
  if __name__ == '__main__':
```
- `doctest.testmod()`を呼び出すことで、ファイル単体でテストを実行できるようにする
- これにより、スクリプトを直接実行するだけでテストが実行される

```python
`python doctest_module.py`
```

- `doctest.testmod(verbose=True)`とすることで、
成功・失敗に関わらず詳細な出力を表示させることができる

**例：doctest_module.py**

### 例外の記述
- `doctest`で例外を扱うには、**期待される例外がドキュメント文字列内で発生することを明示的に示す**
- `doctest`では、例外が発生した際に、**その例外の名前とメッセージを記述**することで、テストケースとして扱える

**基本的な形式**:
1. 例外が発生するコードを **`>>>` の後に記述**する
2. その次の行に、**発生が期待される例外の名前とメッセージを記述**する

**ポイント**
- **`Traceback (most recent call last):`** と **`...`** の行は必須
  - これにより、`doctest`はこの部分がトレースバックの開始点であることを認識する
- `...` は、**トレースバックの途中にある詳細な情報**（ファイル名、行番号など）を**無視**するためのワイルドカード
  - これにより、環境に依存するテストの失敗を防げる
- 最後の行に、期待される**例外の型とメッセージ**を記述する
  - **この部分がコードの出力と一致するか**どうかがテストされる
  - メッセージは部分的に一致していれば成功となるため、厳密な一致が必要ない場合はより短いメッセージにすることも可能

### 複数の例外を扱う場合
- 複数の例外タイプをテストする場合も、同様の方法でそれぞれの例外を記述する

**例：doctest_except.py**

### テキストファイル中の実行例をテストする

- **`doctest.testfile()`**は、Pythonの`doctest`モジュールの一部で、**テキストファイル内のPythonインタラクティブセッションの例をテストする**ための関数
    - これにより、Pythonのコードだけでなく、ドキュメントファイルやREADMEファイルなどに書かれたコード例も自動的にテストできる

**例：**
1. **テスト対象のファイルを作成する**
    - まず、テストしたいコード例を含むテキストファイル（例: example.txt）を作成する
        - このファイルはPythonのプログラムである必要はない。
    - ドキュメント文字列と同じように、`>>>`で始まるコードと、
    その直後の期待される出力を記述する

2. **`testfile()`を呼び出すスクリプトを作成する**
    - 次に、doctestモジュールをインポートし、doctest.testfile()を呼び出すPythonスクリプト（例: doctest_testfile.py）を作成

3. **テストを実行する:Bash**
    - このスクリプトを実行すると、example.txt内のコード例が自動的に実行され、結果が期待される出力と一致するか検証される
    - テストに失敗した場合は、エラーメッセージが表示される

- `testfile()`は.txt、.rst、.mdなど、**Pythonのコードファイルではないドキュメント内の例もテストできる**

**例：doctest_testfile.py**

## ユニットテストフレームワークを利用する `unittest`

- `unittest`は、Pythonに標準で搭載されている**テストフレームワーク**
- `doctest`が**ドキュメント内のコード例をテスト**するのに対し、`unittest`はより**本格的で構造的なテスト**を書くための仕組みを提供する

### テストを作成して実行する

1. **テストファイルの作成**
    - テスト対象のコードとは別に、テスト専用のPythonファイルを作成する
        - ファイル名は **`test_`で始めるのが一般的**（例: `test_my_module.py`）

2.  **`TestCase`クラスの定義**
    - 作成したテストファイル内に、**`unittest.TestCase`** クラスを継承したテストクラスを定義
        - クラス名は **`Test`で始める** のが慣例

```python
import unittest

class TestMyFunction(unittest.TestCase):
    # ここにテストメソッドを記述
    pass
```

3. **テストメソッドの作成**
- テストクラス内に、**`test_`で始まるメソッド**を作成する
    - これが個別のテストケースになる
- メソッド内で、**テストしたい関数の呼び出**しと、期待される結果を検証するための**アサーションメソッド**を記述する

4. **テストの実行**
    - テストを実行する方法はいくつかある

**a. コマンドラインからの実行**

- `unittest`モジュールを直接呼び出すのが最も一般的な方法

```python
# 現在のディレクトリ内のすべてのテストファイルを自動的に発見して実行
python -m unittest discover

# 特定のテストファイルを実行
python -m unittest test_my_module.py
```

**b. テストスクリプト内での実行**

- テストファイルの末尾に以下のコードを追加すると、
そのファイルを直接実行するだけでテストが実行される

```python
if __name__ == '__main__':
    unittest.main()
```

- このコードを追加したファイルは、以下のように実行する

```python
python test_my_module.py
```

- `unittest.main()`は、`test_`で始まるすべてのメソッドを自動的に見つけ出して実行する

**例：test_my_module.py**

### 様々な条件や失敗を記述する

**`assertEqual`と`assertNotEqual`**
- オブジェクトが等しいか、または等しくないかを検証

| メソッド名 | 説明 |
| --- | --- |
| `assertEqual(a, b)` | `a == b`が`True`であることを検証 |
| `assertNotEqual(a, b)` | `a != b`が`True`であることを検証 |

**`assertTrue`と`assertFalse`**
- 式が`True`か、または`False`になることを検証

| メソッド名 | 説明 |
| --- | --- |
| `assertTrue(x)` | `bool(x)`が`True`であることを検証 |
| `assertFalse(x)` | `bool(x)`が`False`であることを検証 |


**`assertIs`と`assertIsNot`**
- オブジェクトが同一であるか、または同一でないかを検証
  - これは`is`演算子と同じ挙動で、**オブジェクトのIDを比較**する

| メソッド名 | 説明 |
| --- | --- |
| `assertIs(a, b)` | `a is b`が`True`であることを検証 |
| `assertIsNot(a, b)` | `a is not b`が`True`であることを検証 |

**`assertIsNone`と`assertIsNotNone`**
- オブジェクトが`None`であるか、または`None`でないかを検証

| メソッド名 | 説明 |
| --- | --- |
| `assertIsNone(x)` | `x is None`が`True`であることを検証 |
| `assertIsNotNone(x)` | `x is not None`が`True`であることを検証 |

**`assertIn`と`assertNotIn`**
- 要素がコンテナ（リスト、タプル、辞書など）に含まれているか、または含まれていないかを検証

| メソッド名 | 説明 |
| --- | --- |
| `assertIn(a, b)` | `a in b`が`True`であることを検証 |
| `assertNotIn(a, b)` | `a not in b`が`True`であることを検証 |

**`assertIsInstance`と`assertNotIsInstance`**
- オブジェクトが指定されたクラスのインスタンスであるか、またはそうでないかを検証

| メソッド名 | 説明 |
| --- | --- |
| `assertIsInstance(obj, cls)` | `isinstance(obj, cls)`が`True`であることを検証 |
| `assertNotIsInstance(obj, cls)` | `isinstance(obj, cls)`が`False`であることを検証 |


**`assertRaises`**
- 指定したコードブロックが、特定の例外を発生させることを検証
- `assertRaises`は **`with`文と組み合わせて使う**のが一般的で、より読みやすく、柔軟なテストが書ける

| **メソッド名** | **説明** |
| --- | --- |
| `assertRaises(exc, callable, *args, **kwargs)` | `callable(*args, **kwargs)`が`exc`を発生させることを検証 |

**例：test_unittest_sample.py**

### 1つのテストメソッドの中で複数のアサーションメソッドを呼ぶ `subTest()`

- **`unittest.TestCase.subTest`** は、**テストメソッド内で複数の独立したテストケースを実行**し、それぞれを**個別のテストとして報告**するための機能
- これにより、ループ処理などで複数の入力をテストする場合に、**最初の失敗でテスト全体が中断されることなく、すべてのテストケースが実行**され、どのケースが失敗したかを正確に把握できる

**`subTest`を使用しない場合の問題点**
- たとえば、複数の入力値をループでテストする場合、`self.assertEqual`が一度でも失敗すると、テストメソッド全体がそこで停止してしまう
  - これにより、他の入力値に対するテスト結果が不明なままとなる

```python
# subTestを使用しない例
def test_addition_multiple_inputs(self):
    test_cases = [(1, 2, 3), (3, 4, 7), (5, 5, 11)] # 最後のケースは失敗する
    for a, b, expected in test_cases:
        result = a + b
        self.assertEqual(result, expected) # ここでテストは中断される
```

- この場合、**`(5, 5, 11)`** のテストケースは実行されない

**`subTest`の使用方法**
- **`subTest`** は、`with`ステートメントを使用して、ブロック内のコードを個別のテストとして扱う
  - `subTest`のコンテキスト内で実行されたアサーションが失敗しても、ループは続行される

**例：test_subtest.py**

### テストの事前準備を行う `setUp()`・`setUpclass()`

- **`setUp`** と **`setUpClass`** は、**`unittest.TestCase`** クラスで使用される特別なメソッドで、**テストの準備と後処理を行う**ためのもの
- 両者は実行されるタイミングとスコープが異なる

**`setUp`メソッド**
- **実行タイミング**：
  -  各テストメソッド (`test_`で始まるメソッド) が実行される**直前**に呼び出される
- **スコープ**：
  - テストメソッドごとに**独立した初期化処理**を行う
  - これにより、**各テストが他のテストの影響を受けない**、クリーンな状態で実行されることが保証される
- **使用目的**：
  - **テストごとに新しいオブジェクトやリソースを作成**する場合に使用
  - 例：テストデータ、モックオブジェクト、データベース接続など

**`setUpClass`メソッド**
- **実行タイミング**：
  - テストクラス内の**すべてのテストメソッドが実行される前**に、**一度だけ**呼び出される
- **スコープ**：
  - クラス全体で共有される準備処理を行う
- **使用目的：** 
  - テストクラス全体で共通して使用する、コストのかかるリソースの初期化に使用
  - 例：データベース接続の確立、テスト用ファイルの一括作成、計算量の多いセットアップ

**注意点：** 
- **`setUpClass`** は**クラスメソッド**であるため、**`@classmethod`デコレータを付ける**必要がある
- また、引数としてクラス自身（`cls`）を受け取る

|  | **`setUp`** | **`setUpClass`** |
| --- | --- | --- |
| **実行回数** | 各テストメソッドごとに1回 | テストクラスごとに1回 |
| **デコレータ** | 不要 | `@classmethod`が必要 |
| **引数** | `self` | `cls` |
| **主な用途** | 各テストの独立性を保つための初期化 | クラス全体で共有するリソースの準備 |
| **テストの独立性** | 各テストは独立している | 共有リソースを使用するため、テスト間で依存関係が生じる可能性がある |

**例：test_setup_setupclass.py**


### テスト事後処理を行う　**`tearDown()`**・`tearDownClass()`
- `unittest`における **`tearDown`** と **`tearDownClass`** は、それぞれ **`setUp`と`setUpClass`に対応する後処理用のメソッド**
- これらは、テストの実行後にリソースを解放したり、状態をクリーンアップしたりするために使用される

**`tearDown`メソッド**
- `tearDown`メソッドは、**各テストメソッドが実行された直後**に呼び出される
  - これは **`setUp`で準備した内容を元に戻す** ために使われる
- **実行タイミング**： 
  - **各テストメソッドの後に1回ずつ**
- **スコープ**： 
  - テストメソッドごとの後処理
- **主な用途**： 
  - `setUp`で作成したオブジェクトの削除、ファイルハンドルのクローズ、データベースセッションのロールバックなど**各テストで個別に作成されたリソースを解放**する目的で使われる

**`tearDownClass`メソッド**
- `tearDownClass`メソッドは、**テストクラス内のすべてのテストメソッドの実行が完了した後**に、**一度だけ**呼び出される
- **実行タイミング**：
  - テストクラスの最後に1回
- **スコープ**：
  - クラス全体の後処理
- **主な用途**：
  - **`setUpClass`** で準備した、**テストクラス全体で共有されるリソースを解放**する目的で使われる

**注意点**：
- `setUpClass`と同様に、`@classmethod`デコレータを付け、引数としてクラス自身（`cls`）を受け取る

|  | **`tearDown`** | **`tearDownClass`** |
| --- | --- | --- |
| **実行回数** | 各テストメソッドごとに1回 | テストクラスごとに1回 |
| **デコレータ** | 不要 | `@classmethod`が必要 |
| **引数** | `self` | `cls` |
| **主な用途** | 各テストの独立性を保つための後処理 | クラス全体で共有したリソースの解放 |
| **注意点** | `setUp`とセットで使うことが多い | `setUpClass`とセットで使うことが多い |

**例：test_teardown_teardownclass.py**

### コマンドラインインタフェースを利用する

- `unittest`は、**コマンドラインから直接実行**してテストを実行できる
    - これによりテストランナーのスクリプトを作成することなく、素早くテストを実行できる

```python
python -m unittest [オプション] [テストの指定]
```

- `python -m unittest`は、Pythonに`unittest`モジュールを実行させるためのコマンド
    - これにより、指定されたテストが自動的に発見されて実行される

- `unittest`コマンドには、テストの実行方法を制御するための様々なオプションがある。

| **オプション** | **説明** |
| --- | --- |
| **`-f`, `--failfast`** | 最初の失敗またはエラーが発生した時点でテストの実行を停止 |
| **`-b`, `--buffer`** | テストの実行中に標準出力と標準エラー出力をバッファリングする <br> 失敗またはエラーが発生した場合にのみ、それらを出力する |
| **`-k`** | 特定のパターンに一致するテストメソッドやクラスのみを実行する <br> 例：`python -m unittest -k "test_user"` <br>名前に`test_user`を含むテストを実行する |
| **`-s`, `--start-directory`** | テストを発見する開始ディレクトリを指定 <br> デフォルトはカレントディレクトリ |

- **`discover`サブコマンド**は、**指定されたディレクトリからテストファイルを自動的に見つけ出して実行**するための強力な機能
- `python -m unittest discover`の後にオプションを付ける

| **オプション** | **説明** |
| --- | --- |
| **`-s`, `--start-directory`** | **テストを探索する開始ディレクトリ**を指定 <br> プロジェクトのルートディレクトリなどを指定し、そこから再帰的にテストを探させることができる <br> デフォルトはカレントディレクトリ |
| **`-p`, `--pattern`** | **テストファイル名に一致するパターン**を指定 <br> デフォルトは`test*.py` <br> 例えば`*_test.py`という命名規則を使っている場合は`--pattern "*_test.py"`と指定 |
| **`-t`, `--top-level-directory`** | **プロジェクトのトップレベルディレクトリ** を指定 <br> このディレクトリは、テストモジュールのインポート時にルートパスとして扱われる <br> `start-directory`がトップレベルディレクトリの子ディレクトリである場合に特に有用 |
| **`-v`, `--verbose`** | `unittest`自体のオプションと同様に、詳細な出力を表示 |

- **例：`tests`ディレクトリ内にテストファイルが配置されているプロジェクト構造**

```python
my_project/
├── src/
│   └── my_app.py
└── tests/
    ├── __init__.py
    └── test_my_app.py
```

- このプロジェクトのルートディレクトリ（`my_project`）から、`tests`ディレクトリ内のテストを実行するには、以下のコマンドを実行する

```python
# my_project ディレクトリで実行
python -m unittest discover -s tests
```

- これにより、**`tests`ディレクトリ内の`test_my_app.py`が発見され、テストが実行される**

## 16.3 モックを利用してユニットテストを行う `unittest.mock`

- `unittest.mock`は、Pythonの標準ライブラリ
- **テスト中にオブジェクトの振る舞いを置き換える**ための強力なツール
- これにより、外部サービスやデータベースといった、**テストが困難な依存関係を持つコンポーネントを隔離してテスト**できる
- `mock`を使うことで、テスト対象のコードが正しく動作するかを**依存関係の実際の振る舞いに左右されることなく検証**できる

### モックオブジェクトを作成して戻り値や例外を設定する `Mock`・`MagicMock`

**`Mock`クラス**
- `Mock`は、最も基本的なモックオブジェクト
  - `Mock`インスタンスは、本物のオブジェクトのように振る舞うが、**実際には何もしない**
    - 呼び出されたメソッドや属性にアクセスされた履歴をすべて記録する

**`Mock`の主な機能：**
- **関数の置き換え**：
  - `patch`デコレータなどを使って、テスト対象の関数の内部で呼び出される別の関数やメソッドを`Mock`オブジェクトに置き換えることができる

- **呼び出し履歴の記録**： 
  - `call_count`・`called`・`call_args`などの属性で、モックがどのように呼び出されたかを検証できる

- **戻り値の設定**： 
  - **`return_value`** 属性に値を設定することで、モックが特定の値を返すようにできる

- **サイドエフェクトの設定**：
  - **`side_effect`** に例外や関数を設定することで、**モックが特定の振る舞い**をするようにできる

**`MagicMock`クラス**
- `MagicMock`は、`Mock`を拡張したクラスで、**マジックメソッド（`__len__`, `__str__`, `__getitem__`など）のモック機能**を自動的に提供する
- これにより、リストや辞書のような**組み込み型の振る舞いを模倣する必要がある場合**に非常に便利
- `MagicMock`は、`Mock`のすべての機能を持ちつつ、**マジックメソッドが呼び出された際の振る舞い**を簡単にカスタマイズできる。
 
**`MagicMock`の主な機能:**
- **マジックメソッドの自動モック**：
  - `len(mock_object)`や`str(mock_object)`といった操作が、エラーなく実行できる

- **マジックメソッドのカスタマイズ**： 
  - `__len__.return_value = 5`のように、
特定のマジックメソッドの戻り値を設定できる

**`Mock`と`MagicMock`の使い分け**
- `unittest.mock`の文脈で単に`Mock`と書いた場合、**通常は`MagicMock`のインスタンスが作成される**
    - これは、**`MagicMock`が`Mock`の上位互換**であり、より多くの機能を提供するため
<br>

- **`Mock`**：
  - **シンプルなメソッドや関数を置き換えるだけ**で十分な場合に有効

<br>

- **`MagicMock`**：
  - **マジックメソッド**を使用するオブジェクトや、**より複雑な振る舞いを模倣する必要**がある場合に適している

<br>

- `unittest.mock`モジュール自体が、デフォルトで`MagicMock`を使用するように設計されているため、**通常は`MagicMock`を使うのが一般的**
- `patch`などの機能も、デフォルトで`MagicMock`のインスタンスを生成する。

**例：test_mock.py**

### クラスやメソッドをモックで置き換える `patch()`

- **`unittest.mock.patch`** は、テスト中に**特定のオブジェクトや属性を一時的に別のオブジェクト（通常はモック）に置き換える**ための強力なツール
- これにより、外部サービスへのAPIコール、データベースアクセス、ファイルシステム操作など、**テストが困難な依存関係を持つコードを隔離してテスト**できる
- `patch`は、主に**デコレーター**と**コンテキストマネージャー**の2つの方法で使用される

**`patch`の主な引数**
- **`target` (必須)**：
  - 置き換えたい対象のオブジェクトへのパスを文字列で指定
  - **テスト対象のコードがオブジェクトをルックアップする場所**を指す
    - 例：`'my_module.my_function'`

- **`new`**：
  - `target`の代わりに使われる新しいオブジェクトを指定
    - 省略された場合は、**デフォルトで`MagicMock`のインスタンス**が使われる

- **`new_callable`**：
  - `target`の代わりに**特定のクラスのモックオブジェクトを作成**したい場合指定
    - 例：**`new_callable=Mock`** とすると、`MagicMock`ではなく`Mock`のインスタンスが作成

- **`spec`**：
  - `True`またはクラスを指定することで、**モックが元のオブジェクトと同じインターフェース（属性やメソッド）を持つことを保証**する
  - これにより、存在しないメソッドを呼び出すとエラーが発生するため、テストの正確性が向上する

1. **デコレーターとして利用する場合**
- `patch`をデコレーターとして使うと、**テストメソッドやテストクラス全体にパッチを適用**できる
- **使い方**
  - テストメソッドのデコレーターとして`@patch('module.object')`を記述する
    - **`patch`はモックオブジェクトをテストメソッドの引数として渡す**
    - 複数の`patch`を重ねて使うこともできる

2. **コンテキストマネージャーとして利用する場合**
- `patch`を`with`ステートメントと組み合わせて使うと、**特定のコードブロック内でのみパッチを適用**できる
- これにより、パッチの適用範囲をより細かく制御できる

**使い方**
- `with patch('module.object') as mock_object:`のように記述する
  - `with`ブロックを抜けると、パッチは自動的に元に戻る

**デコレーターとコンテキストマネージャーの使い分け**
- **デコレーター**：
  - **テストメソッド全体にパッチを適用**したい場合に適している
  - シンプルで読みやすいコードになる
<br>
- **コンテキストマネージャー**：
  - **テストメソッドの一部にだけパッチを適用**したい場合や、**動的にパッチの対象を切り替えたい**場合に有効
  - より柔軟なテストを書くことができる
<br>
- 通常は、**デコレーター**を使うのが一般的だが、`with`文を使うことでよりスコープを明確にできる
- どちらを使っても同じ結果が得られるが、状況に応じて使い分けるのが良い

**例：test_patch.py**

### モックオブジェクトが呼びされたかどうかを確認する

- `unittest.mock`の`Mock`オブジェクトは、**テスト中に呼び出された履歴をすべて記録**する
  - これらの記録を検証するために、以下のようなアサーションメソッドが提供されている
    - これらはモックオブジェクトが期待通りに呼び出されたかどうかを確認する際に利用する

**`assert_called()`**
- モックが**一度でも呼び出されたこと**を検証
- 引数の内容や呼び出された回数は問わない

**`assert_called_once()`**
- **モックが一度だけ呼び出されたこと**を検証
  - 複数回呼び出された場合は失敗

**`assert_called_with(*args, **kwargs)`**
- **モックが最後に呼び出された際の引数が、期待通りであること**を検証
  - 最後の呼び出しだけがチェックされる

**`assert_called_once_with(*args, **kwargs)`**
  - **モックが一度だけ、かつ特定の引数で呼び出されたこと**を検証
    - これは`assert_called_once()`と`assert_called_with()`の組み合わせ

**`assert_not_called()`**
  - **モックが一度も呼び出されなかったこと**を検証

**例：test_mock_confirm.py**