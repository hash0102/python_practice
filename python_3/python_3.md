## 3.1 例外処理

### 例外を処理する
- 例外が発生する可能性がある箇所を **`try-except`** で囲んで例外を補足することで、**プログラムが停止するのを防ぐ**ことができる
  - `except`の後ろには**捕捉したい例外クラス**を指定

**複数の例外を補足**
- **複数の`except`** を用いて発生した例外に応じて処理を分けることもできる。

- **`except`** では丸かっこで囲んだ**タプルを使用して複数の例外を指定**できる

    - また、「**`as 一時変数名`** 」形式で例外オブジェクトを受け取ることができ、**`except`** の中で使用できる

**else節**
- **`try`で例外が送出されなかったときに実行される**処理を書く
    - **例外が発生した場合**は **`else`の中の処理は実行されない**
- **すべての`except`よりも後ろ**に書く

**finally節**
- **例外の発生有無にかかわらず実行される処理**を書く

### 基底クラスで例外を補足
- 例外を表すクラスは**継承階層**を構成しており、**`BaseException`** を親とした **`Exception`** クラスがある
    - この **`Exception`** を継承した形で、子・孫クラスの例外が存在する。
- **`except`** に捕捉したい例外の基底クラスを指定して、その子・孫クラスの例外を補足できる。
- 例では **`except`** に **`ZeroDivisionError`** の**基底クラス**である **`ArithmeticError`** を指定している。
    - `ZeroDivisionError`が発生するが、基底クラスの`ArithmeticError`で捕捉される
    - また、基底クラスで捕捉しても、中身を確認すると実際の例外クラスの **`ZeroDivisionError`** が渡される

### 独自の例外を定義して、例外を送出する
- **`Exception`** クラスを**継承して新しい例外クラスを作成**することで、独自の例外を作成できる。
    - 例外は **`Error`で終わる名前で定義**
- また、`raise`キーワードを使用して、例外を意図的に発生させることも可能

**※注意点**
- 一般的に`try`文で囲む範囲は狭いほうが良いとされている。
- 範囲が広いと`try`文が何を意図しているのか理解するのが困難になり、可読性が落ちる。
- `except`で例外の種類を指定しない、基底クラスを指定することも推奨されない。

**例：except.py**

## 3.2 with文

### with文

**`open`関数：**
- `open`関数とはファイルを開いて対応するファイルオブジェクトを返す組み込み関数
<br>

- 例の二つの処理は同じ処理を行なっている
- 処理中に**例外が発生しても必ず最後にファイルを閉じる**ことで、リソースを確実に開放している
- **`with`文**を使うと、**同じことを`try-finally`ブロックを使って書くより簡潔**に書ける
- **`as`キーワード**は、**戻り値をwithブロックの中で利用したい場合**に指定
    - 例で`as f` でファイルオブジェクトを受け取り、withブロックの中で使用している

### コンテキストマネージャー
- `with`文に渡すオブジェクト
- `__enter__()` と`__exit__()` の特殊メソッドを実装したクラスのインスタンス
  - `open`関数の例では`with`文に`open(’python.txt’)` を渡していたが、**`open`関数が返すオブジェクトがコンテキストマネージャーオブジェクト**
- `dir()`関数にオブジェクトを渡すと、属性やメソッドが取得できるため、そのなかに`__enter__()` と`__exit__()` があるかを確認できる
<br>

- **`with`が実行**されると **`with`ブロックが実行される前** に **`__enter__()` の処理が実行** され、**`with`ブロックの処理が終了した後**で **`__exit__()` の処理が実行**される。
    - **`__enter__()` →`with`→`__exit__()` の順**で実行される。
- withブロックでの例外発生時は **`__exit__()` の引数**で**例外の情報**が受け取れる。
    - `__exit__()` の中で例外を補足しない限り、例外は再送出される。

### 標準ライブラリのデコレーター `@contextlib.contextmanager`

- **`@contextlib.contextmanager`** というデコレーターを使用してジェネレーター関数を記述することで、**コンテキストマネージャーを定義**できる
- **`__enter__()` と`__exit__()` を別々に定義したクラスに書く必要がない**ため、簡潔に定義できる
<br>

- **`yield`文より前に書かれたコード**が **`with`ブロックの開始前に実行** され、**`yield`文より後に書かれたコード** が **`with`ブロックの最後で実行**される
  - また、**`as`キーワードに値を渡したい**場合は、 **`yield`文に値を渡す**
- **`with`ブロック内**で発生した**例外**は **`yield`文を実行している箇所で再送出**されるため、後処理を適切に行うようにするには **`try-finally`** を使用する
    - 使用しないと、例外が`yield`文を実行している箇所で送出されるため、`yield`文の後の処理が行われず終了する

**comtextlibモジュール**では以下のようなコンテキストマネージャーを提供している

| **名前** | **概要** |
| --- | --- |
| `contextlib.suppress(exceptions)` | **`exceptions`で指定した例外を無視**する |
| `contextlib.rdirect_stdout(new_trget)` | 標準出力（`sys.stdout`）を`new_target`に変更する |
| `contextlib.rdirect_stderr(new_trget)` | 標準出力（`sys.stderr`)を`new_target`に変更する |

**例：with.py**

## 3.3 関数の引数

### 位置引数
- 関数呼び出し時に**先頭から順に引数の位置を対応**させて渡されるのが位置引数
- **引数を渡した位置**によって、どの仮引数がその値を受け取るかが決定される
- 位置引数を使用した呼び出しでは関数が必要とする**仮引数の数**と、**渡した実引数の数を一致**させる必要がある。

### キーワード引数
- 関数呼び出し時に「**`kwarg=value`**」という形式で仮引数名を指定して渡す実引数をキーワード引数という
- 関数定義の仮引数リストに並べた順番通りに実引数を渡す必要はない
- 関数の仮引数リストにある名前とキーワードを一致させる必要がある。

### 位置引数とキーワード引数の混在
- 位置引数とキーワード引数は混在させることもできる
  - ただ、**位置引数を先に置き、キーワード引数はそのあとで指定**する必要がある

### デフォルト値付き引数
- 関数呼び出し時、**実引数を省略**したときに使用されている**デフォルト値を仮引数に設定**できる。
    - デフォルト値を設定すると、その引数をオプション項目にできる。
- デフォルト値は文字列、数値、タプルなど**変更不可（イミュータブル）なオブジェクトを指定**する。

### 可変長位置引数
- 仮引数に「**`*`**（アスタリスク）」を付けると、**可変長の位置引数**（任意の数の引数）を定義できる
    - 慣例として仮引数には「**`*args`**」という名前が使われることが多いが、「`*`」が頭についていればどのような名前でも問題ない
- **`*args`** は複数の引数を **タプルとして受け取る**
- `print()`や`max()`などの組み込み関数が可変長位置引数に対応している。
- `*args`は**ほかの位置引数よりも後ろに指定**する
- **可変長位置引数の前**に**デフォルト値付き引数**を定義すると、**呼び出し側でキーワードを指定して使うことができない**ため、基本的に使用しないほうが良い

### 可変長キーワード引数
- 仮引数に「**`**`**」を付けると、可変長のキーワード引数を定義できる。
- 慣例として仮引数には「**`**kwargs`**」という名前が使われることが多いが、「`**`」が頭についていればどのような名前でも問題ない。
- 「`**kwargs`」は複数の**キーワード引数**を **辞書として受け取る** 
  - 一番最後に指定する

これまでの引数は同時に指定できるが、4つの引数が混在する場合は以下の順番で定義する
1. **位置引数**
2. **可変長位置引数**
3. **デフォルト値付きの引数**
4. **可変長キーワード引数**
- 実際は必要最低限の引数を適切に組み合わせて定義する

### キーワード専用引数
- **「`*`」の末尾に定義された引数**は、キーワード専用引数と呼ばれ、**キーワード引数として指定しなければ呼び出せない**という制限を付けることができる
- bool値などを引数として渡す場合、呼び出し側でキーワードの指定がないと、何に対して **`True`/`False`** なのかがわかりづらくなる。
- キーワード引数で明示したほうが可読性を高めることができ、キーワードを強要したいときに使う。

### 位置専用引数
- **「`/`」の前に定義された引数**は、位置専用引数と呼ばれ、**位置引数として指定しなければ呼び出せない**という制限を付けることができる。

**例：param.py**

## 3.4 アンパック

### アスタリスクを使ったアンパック

- 代入される側の変数名の前に「**`*`**」を付けると、**要素がその変数にまとめて代入**される。
    - 「`*`」を付ける変数はどの変数でも問題ないが、**「`*`」は１つの変数にしか適用できない。**

### 関数の引数のアンパック

- **関数の引数**として**タプルやリスト**を渡す際に「**`*`**」を付けると、**中身を展開**して渡すことができる。

**例：unpack.py**

## 3.5 内包表記、ジェネレータ式

### リスト内包表記

- ある**要素を変換**したり、**フィルタリング**したりしたあとに、**新規にリストを作成**するという１点に集中しているため、何をしているか明確で読みやすい。

- **構文**
    
    ```python
    [変数を使った処理 for 変数 in イテラルオブジェクト]
    ```
    
    ```python
    [変数を使った処理 for 変数 in イテラルオブジェクト if 条件式]
    ```

### ネストしたリストの内包表記
- 二重や三重の**多重ループも内包表記**で書ける

### 集合内包表記
- **set型**の値を生成する
- **`[]`を`{}`に変える**と**set型の値**を生成できる。
- 集合内包表記で作成されたものは**重複した要素を持たない。**

### 辞書内包表記
- **dict型**の値を生成する
- **キーと値をコロンでつないだペア**を **`{}`** で囲む

### ジェネレーター式
- ジェネレーターオブジェクトを生成する。
    - ジェネレーター式は、**リスト内包表記と同じ記法を丸かっこで囲むことで表現**できる。
        - **タプル型ではない**
- ジェネレーターのため、値を取得するまで次の値が作られない。

**例：comprehension.py**

## 3.6 ジェネレーター
- **イテレーターを返す特殊な関数**
- **繰り返し処理のタイミング**に応じて結果を返すことができる

### ジェネレーター
**通常の関数とジェネレーターの違い**
- **`return`** の代わりに **`yield`** を使用する
- ジェネレーターでは **`for`** の途中に **`yield`** が使用されており、結果として**ジェネレーターオブジェクトが返されている**。
- ジェネレーターオブジェクトは**イテラルなオブジェクト**で、リストオブジェクトと同様に **`for`** を用いて値を取り出せる
    - 例では確認のために結果を代入しているが、単純に結果を利用するだけであれば、以下のように使用できる
```python
for i in muliplier(values):
```
- **関数内で`yield`が使用**されると、pythonがこの関数を**ジェネレーターと判断**し、ジェネレーターオブジェクトを生成する
- **`yield`は、実行された時点の値を返し**、その位置で一時停止の状態になり**次の呼び出しを待つ**
    - 例の一時停止の状態は、状態が保持されたイテラルオブジェクトになっており、計算途中の状態を保持し、必要なデータを１つずつ返すことができるイテレーターが返されることになる
- このような動作から、ジェネレーターは**データが大量になってもメモリリソースを消費することなく**処理を行うことができる。

**ジェネレーターで`next()`関数を使用する**
- **`next()`** 関数はイテレーターから次の値を１つ取り出すことができる組み込み関数
    - ジェネレーターオブジェクトの **`__next__()`** メソッドを呼び出している。

| **関数** | **概要** | **戻り値** |
| --- | --- | --- |
| `__next__()` | ジェネレーターの実行、または最後に`yield`が実行された位置から再開する。<br>返す値が存在しない場合は`StopIteration`を送出する。 | 次の`yield`文までに得られた値 |

- ジェネレーターオブジェクトは状態が保持されたイテラルオブジェクト。
    - 連続されたデータを処理する場合、`for`文が使用されることが多いが、
    `next()`関数を使用することで**任意のタイミングで値を１つずつ取得**できる。

### `list()`関数を使用してリストに変換する
- **リストオブジェクト**は要素の追加が大きくなるほど**プログラムのメモリ消費も大きくなる**
    - 通常の関数でリストオブジェクトを返す場合は関数が何度も呼ばれたり、サイズが大きくなったりするにつれてパフォーマンスも影響する。
- それに対して**ジェネレーターはイテラルオブジェクトを返すのみ**なので、処理中にメモリを食い尽くす心配をなしに、大きいサイズのシーケンスを取り扱える。
- 最終的にリストオブジェクトに返したいときに、**ジェネレーターオブジェクトは`list()`関数を使用してリストオブジェクトに変換**できる

### 大きいファイルの処理にジェネレーターを使用

- ファイル読み込みでは`for`が使用されることが多いが、必要なデータをすべてリストオブジェクトなどに追加してから処理を行うと、ファイルサイズが大きくなるにつれて、メモリの消費量も大きくなる。
    - **ジェネレーターを使用すると、ファイル読み込みのループ処理中に対象のデータを１つずつ取り出しながら処理を行うことができる**ため、１行分のメモリ程度で処理できる。
      - また、対象のデータを処理するコードはジェネレーターとは別にコーディングできるため、コードが読みやすくもなる。
<br>
- 処理の流れとしては、ジェネレーターは処理対象の１行を返して**ファイルの読み込みを一時停止**
    - 行に対する処理を実行
        - 一時停止していた**ファイル読み込みを実行しているジェネレーターが再開**

**例：generator.py**

## 3.7 デコレーター
- デコレーターは関数やメソッド、クラスをデコレート（装飾）する機能。
    - デコレーターを使用すると、**関数やメソッドクラスそのものの中身を変えずに共通のロジックを適用できる**ので便利
- デコレーターを適用する方法は適用したい対象の上に「**`@デコレーター名`**」と１行を追加するだけ

### デコレーターを使用する
- デコレーターを適用する関数やメソッド、クラス定義の前に「**`@デコレーター名`**」を付けるだけ
- デコレーターは**シンタックスシュガー**のため、以下のデコレーターの構文と代入文は等価。

> ##### シンタックスシュガー（Syntax Sugar）
>- シンタックスシュガー（Syntax Sugar）とは、プログラミング言語において、より**読みやすく、簡潔に書ける**ようにするために導入された構文のこと
>- この構文を使わなくても同じ機能を実現することは可能だが、開発者の負担を軽減し、コードの可読性を高める目的で設計されている

**関数デコレーターを使用する**
- サードパーティライブラリの`retrying`は、デコレート対象の関数内で例外が発生した際に、再度関数の実行を行ってくれるデコレーター **`retry`** を提供する。

**インストール方法**
```bash
$pip install retrying
```
- 例は`my_func`関数の上に`@retry`を指定
    - `my_func`は0~10の範囲でランダムに整数を生成し、５以外の数字の場合は例外を発生する
    - しかし、`retry`デコレーターを適用することで、5以外の数字が生成され例外が発生しても、再度`my_func`が実行され、例外が発生しなくなるまで関数の実行がリトライされる。
- このようにデコレーターの利点は、デコレート対象の関数には何も変更を加えないで、**デコレーターを１行追加するだけでデコレート対象の関数の前後で処理を追加して実行できる。**

**クラスデコレーターを使用する**
- クラスやクラスのメソッドにもデコレーターを適用できる。
- 使い方は**クラスやメソッドの前**に「**`@デコレーター名`**」と１行を追加するだけ

**2つ以上のデコレーターを適用する**
- １つの関数やメソッド、クラスに複数のデコレーターを適用できる
- **１行ごとに１つのデコレーターを指定**

### 関数デコレーターを自作する
- デコレーターは対象のオブジェクトを置き換えるための機能。

**例：代入文**
```python
func = my_decorator(func)
```

- デコレーターもただの関数
- `my_decorator`関数（デコレーター関数）は関数`func`を引数にとり、返された結果を`func`に代入することで`func`を置き換えている
- pythonでは関数を引数として受け取ったり、戻り値として関数を返すことができ、このような関数を**高級関数**という

### `functools.wraps`を使用する
- デコレーターを使用すると**関数が置き換わる**ため、**元の関数名や`docstring`が失われ**、ログを表示したい場合やエラーが発生した場合などでは正しく表示されない
- この問題を回避するために、**`functools.wraps`** がある。
    - これを設定すると、**名前や `docstring`をもとのデコレート対象の関数のものに設定**してくれる
- **`warps`** はデコレーターなので、wrapper関数に **`wrpas`デコレーター** を適用し、引数に元のデコレート対象の関数を設定する

**例：decorator.py**