## 17.1 対話的なデバッグを行う `pdb`・`breakpoint`

**`pdb`とは何か**
- **`pdb`** は、Pythonの標準ライブラリに組み込まれている対話型デバッガ
  - コードの実行中にプログラムを一時停止させ、変数の値を確認したり、ステップ実行したりすることで、バグの原因を特定するのに役立つ

### 代表的なデバッガーコマンド

| **コマンド** | **省略形** | **説明** |
| --- | --- | --- |
| **`help`** | **`h`** | **コマンド一覧を表示** <br> 引数にコマンド名を入れると、そのコマンドの詳細なヘルプが表示される |
| **`where`** | **`w`** | **現在のスタックトレースを表示** <br> どの関数から現在の位置にたどり着いたかを確認できる |
| **`next`** | **`n`** | **現在の行を実行**し、**次の行**に移動する <br> 関数呼び出しがあっても、その関数内部には入らず呼び出し元の次の行に進む |
| **`step`** | **`s`** | 現在の行を実行し、**次の実行可能な行**に移動する <br> `next`とは異なり、**関数呼び出し**がある場合はその関数内部に入ってステップ実行を続ける |
| **`list`** | **`l`** | **現在の行の周りのソースコードを表示**する <br> 引数で特定の行範囲を指定することもできる |
| **`continue`** | **`c`** | ブレークポイントに到達するまで、またはプログラムが終了するまで実行を再開する。 |
| **`print`** | **`p`** | 指定した式の値を表示 <br> 例えば、`p my_variable`と入力すると、`my_variable`の値が表示される |
| **`pprint`** | **`pp`** | `p`と同様ですが、`pprint`モジュールを使ってより見やすく整形して表示 <br> 特に辞書やリストなどの複雑なデータ構造で便利 |
| **`quit`** | **`q`** | デバッガを終了し、プログラムの実行を強制的に停止 |

```python
# p や pp コマンドを使って変数の値を確認
(Pdb) p a
1
(Pdb) pp my_dict
{'key1': 'value1', 'key2': 'value2'}

# n や s コマンドで実行を制御
(Pdb) n # 次の行へ
(Pdb) s # 関数内部へ`
```

### pdbでブレークポイントを挿入する

- **`pdb.set_trace()`** は、Pythonのデバッガー`pdb`を
**コードの特定の場所で起動**させるための最も一般的な方法
- この関数をコードに挿入することで、**その行に到達した時点でプログラムの実行が一時停止**し、対話型のデバッグセッションが開始される
- これによりその時点での変数の値を確認したり、プログラムの実行を制御したりが可能に

**`pdb.set_trace()`の使用方法**
- `pdb.set_trace()`を使用するには、まず`pdb`モジュールをインポートする必要がある
- 次に、デバッグしたい行の直前に`pdb.set_trace()`を記述

**例：pdb_debug.py**

### `breakpoint()`関数でブレークポイントを挿入

- `breakpoint()`は、Python 3.7以降で導入された組み込み関数で、**コードの実行中にデバッガを起動させる**ための簡潔で柔軟な方法
    - これは、`import pdb; pdb.set_trace()`の代替として推奨されている
- `breakpoint()`を呼び出すと、プログラムの実行がその行で一時停止し、インタラクティブなデバッグセッションが始まる
- これにより、その時点での変数の値を確認したり、プログラムの実行をステップ実行したりできる
- **簡潔な記述**：`import pdb; pdb.set_trace()`と書く必要がなく、**`breakpoint()`だけでデバッガを起動できる**
    - コードの可読性を向上させ、デバッグコードを一時的に挿入・削除する手間を減らす

**例：pdb_breakpoint.py**

|  | `breakpoint()` | `pdb.set_trace()` |
| --- | --- | --- |
| **Pythonバージョン** | 3.7以降 | 全バージョンで利用可能 |
| **利便性** | 組み込み関数で、`import`不要 | `import pdb`が必要 |
| **柔軟性** | 環境変数でデバッガを切り替え可能 | `pdb`に固定 |
| **推奨** | 推奨される | 簡潔さの点から非推奨 |

### 異常終了するスクリプトをデバッグする `pdb.pm()`

- `pdb.pm()`は、Pythonのデバッガ`pdb`の便利な機能の一つで、**例外が発生した直後にデバッガを起動する**ためのもの
- これにより、プログラムがクラッシュした時点の状態をインタラクティブに調査ができる

**`pdb.pm()`の基本的な使い方**

**エラーが発生するコード**
``` python
def div(a, b):
    return a / b

def main():
    div(1, 0)

if __name__ == "__main__":
    main()
```

**1. pdbでの実行方法**
``` bash
python -m pdb pdb_pm.py
```
- `**-m pdb：pdb**`を有効にして実行
- 実行すると自答的に対話モードに移行
  - 最初の行で停止する

``` bash
$ python -m pdb pdb_pm.py
> c:\xxx\xxx\python_practice\python_17\pdb_pm.py(1)<module>()
-> def div(a, b):
(Pdb)
```

**2. プログラム実行の流れ**
- pdb起動（まだエラーなし）
- **`c` で実行継続**
``` bash
(Pdb) c
```

**エラー発生**
``` bash
ZeroDivisionError: division by zero
Uncaught exception. Entering post mortem debugging
Running 'cont' or 'step' will restart the program
> c:\xxx\xxx\python_practice\python_17\pdb_pm.py(2)div()
-> return a / b
```
- **`post mortem debugging`（事後デバッグ）に自動移行**

**3. 変数の中身を確認**
``` bash
(Pdb) p a
1
(Pdb) p b
0
```

**4. 呼び出し元を確認**
``` bash
(Pdb) u
> c:\xxx\xxx\python_practice\python_17\pdb_pm.py(5)main()
-> div(1, 0)
```

- `main()` から `div(1, 0)` を呼んでいて、引数の渡し方が間違いということがわかる

**対話モードで自動的にデバッグモードへ移行**
``` bash
>>> import pdb_pm
>>> pdb_pm.main()
```

- **実行結果**
``` python
>>> import pdb_pm
>>> pdb_pm.main()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    pdb_pm.main()
    ~~~~~~~~~~~^^
  File "C:\Users\ha4mo\python_practice\python_17\pdb_pm.py", line 5, in main
    div(1, 0)
    ~~~^^^^^^
  File "C:\Users\ha4mo\python_practice\python_17\pdb_pm.py", line 2, in div
    return a / b
           ~~^~~
ZeroDivisionError: division by zero
```

**`pdb.pm()`の利点**
- **迅速なデバッグ**： 
  - プログラムを再実行する必要なく、**エラーが発生した瞬間の状態にアクセス**できる
  - `pdb.set_trace()`をコードに挿入して再実行する手間が省ける
- **事後デバッグ**：
  - プログラムが予期せずクラッシュした場合でも、トレースバックの情報から原因を調査できる

**例：pdb_pm.py**

## 17.2 コードの実行時間を計測する `timeit`
- `timeit`は、Pythonの標準ライブラリの一つで、**小さなPythonコードの実行時間を正確に測定する**ためのツールです
- コードのパフォーマンスを比較したり、ボトルネックを特定したりする際に使う
- `timeit`は、**測定対象のコードを複数回実行**し、その平均時間を計算することで、OSや他のプロセスによる影響を最小限に抑えた正確な測定を可能にする

### コマンドラインインタフェースで計測する
- `timeit`モジュールをコマンドラインから利用すると、簡単なPythonコードの実行時間を素早く計測できる

```python
python -m timeit [オプション] '測定したいコード'
```

- **コマンドオプションの詳細**

| **オプション** | **説明** |
| --- | --- |
| `-n N` <br> `--number=N` | 測定対象のコードを **ループする回数** を指定 <br> この回数が少ないと誤差が大きくなるため、実行時間が短いコードでは大きな値を設定することが推奨される |
| `-r N` <br> `--repeat=N` | 測定を**繰り返す回数**を指定 <br> デフォルトは5回<br> `timeit`は、このN回の繰り返しの中で**最も速かった時間を採用**する <br> これにより、システムの負荷変動によるノイズを排除し、より正確な実行時間を取得できる |
| `-s "SETUP_CODE"` <br> `--setup="SETUP_CODE"` | 測定対象のコードを実行する**前に一度だけ実行するセットアップコード**を指定 <br> これにより、変数やオブジェクトの初期化にかかる時間を測定時間から除外できる |
| `-p` <br> `--process` | **プロセス間で共有される時間**（タイムスタンプ）ではなく、プロセス自身の実行時間（**ウォールクロック時間**）を測定 <br> より正確なプロセスごとの実行時間が必要な場合に便利 |
| `-u UNIT` <br> `--unit=UNIT` | 結果の表示単位を指定 <br> `usec`（マイクロ秒）、`msec`（ミリ秒）、`sec`（秒）などが使える <br> `timeit`はデフォルトで最適な単位を自動的に選択する |
| `-v` <br> `--verbose` | 詳細な出力を表示 <br>各繰り返しごとの測定結果や、ベストタイム、平均値、標準偏差などが表示される |

1. **シンプルなコードの計測**
    - `n`と`r`を使い、リスト内包表記のパフォーマンスを計測

``` bash
# 1000回ループを5回繰り返して計測
$ python -m timeit -n 1000 -r 5 "[i*2 for i in range(100)]"
1000 loops, best of 5: 2.17 usec per loop
```
<br>

2. **セットアップコードを利用した計測**
- `s`を使い、測定対象の変数（`x`）を事前に定義し、その後の`x.find()`メソッドの実行時間だけを計測

```bash
# xの初期化は1回だけ行われる
$ python -m timeit -s "x = 'a' * 10000" "x.find('a')"
10000000 loops, best of 5: 26.9 nsec per loop
```

<br>

3. **詳細な出力を確認**
- `v`オプションを使うと、より詳しい測定結果が表示される

```python
$ python -m timeit -v "sum(range(100))"
1 loop -> 1.5e-06 secs
2 loops -> 2.9e-06 secs
5 loops -> 4.1e-06 secs
10 loops -> 6.6e-06 secs
20 loops -> 1.11e-05 secs
50 loops -> 2.59e-05 secs
100 loops -> 5.2e-05 secs
200 loops -> 0.000106 secs
500 loops -> 0.000255 secs
1000 loops -> 0.000508 secs
2000 loops -> 0.000991 secs
5000 loops -> 0.00219 secs
10000 loops -> 0.00456 secs
20000 loops -> 0.00908 secs
50000 loops -> 0.0209 secs
100000 loops -> 0.0412 secs
200000 loops -> 0.0812 secs
500000 loops -> 0.204 secs

raw times: 203 msec, 203 msec, 203 msec, 203 msec, 210 msec

500000 loops, best of 5: 406 nsec per loop
```

### Pythonインタフェースで計測する

- `timeit`モジュールをPythonスクリプト内で利用する際は、**`Timer`クラス**を使うのが最も柔軟で強力な方法
- `Timer`クラスは、**コードの実行時間を詳細に制御して測定**するための機能を提供する

**`timeit.Timer`クラス**
- `Timer`クラスは、**計測対象のコードとセットアップコードを指定**してインスタンスを作成
    - これにより、計測環境を独立させて、より正確な時間を測定できる

**コンストラクタ**

- **`Timer(stmt='pass', setup='pass', timer=default_timer)`**
  - `stmt`：
    - 計測対象のコードを文字列で指定
  - `setup`：
    - `stmt`を実行する前に一度だけ実行されるセットアップコードを文字列で指定
  - `timer`：
    - 測定に使用するタイマー関数を指定
    - 通常はデフォルトのままで問題ない

**`timeit()`メソッド**
- `Timer`インスタンスの`timeit()`メソッドは、計測対象のコードを複数回実行し、その合計時間を返す
- `timeit(number=1000000)`
  - `number`：
    - 計測対象のコードをループする回数を指定
    - 合計時間なので、ループ回数で割ることで1回あたりの平均時間が求められる

**例：timeit_method.py**

**`repeat()`メソッド**
- `repeat()`メソッドは、`timeit()`メソッドの処理を複数回繰り返し、その結果を**リスト**として返す
  - これにより、**測定のブレを考慮した結果**を得ることができる
- **`repeat(repeat=5, number=1000000)`**
  - `repeat`：
    - `timeit()`の実行を繰り返す回数を指定
  - `number`： 
    - `timeit()`と同様に、ループ回数を指定
    - `repeat()`は通常、最も速かった時間（ベストタイム）を採用するために使用される

**例：repeat_method.py**

## ログを出力する `logging`

- Pythonの`logging`モジュールは、**アプリのログ出力を管理**するための標準ライブラリ
- このモジュールを使うと、ログメッセージの出力先（ファイル、コンソールなど）や、出力するログの深刻度（ログレベル）を細かく制御できる

### 標準で定義されているログレベル

- `logging`モジュールには、以下の6つの**標準ログレベル**が定義されており、
それぞれ重要度に応じて使い分けられる。
- これらのレベルは、数値で管理されており、数値が大きいほど深刻度が高いことを示す。

**`NOTSET`**：`０`
- ロガーに設定されている場合、そのロガーには**特定のログレベルが設定されていない**
- メッセージを処理する際に**親ロガーのログレベルを継承する**
  - つまり、親ロガーのレベルが`INFO`なら、このロガーも`INFO`として振る舞う

**`DEBUG`**： `10`
- 最も詳細な情報で、主に**問題の診断時**に使用される
- 開発者がコードの動作を追跡するために使うような、非常に細かい情報を含む

**`INFO`**： `20`
- アプリケーションが**期待通りに動作**していることを確認するための情報
  - 例えば、アプリケーションの起動やユーザーが特定の操作を完了したことなどを記録する

**`WARNING`**：`30`
- 予期せぬ事態が発生したが、**アプリケーション自体はまだ正常に動作**している状態
  - 例えば、設定ファイルが見つからない場合などに使われる

**`ERROR`**：`40`
- アプリケーションが特定の機能を実行できなかったが、**全体としてはまだ実行し続けられる**エラー
  - 例えば、データベースへの接続が失敗した場合など

**`CRITICAL`**：`50`
- アプリケーションが致命的なエラーにより、**正常な動作を継続できなくなった**状態
  - 通常、このレベルのログが出力されると、アプリケーションは終了する

<br>

- `logging`モジュールは、**階層的なログレベル**を持っている
- ロガー（`Logger`オブジェクト）に設定されたレベル以上の深刻度を持つログメッセージのみが出力される

**例：ロガーのレベルが`INFO`に設定されている場合**
- `INFO`, `WARNING`, `ERROR`, `CRITICAL`のメッセージが出力される
  - **`DEBUG`メッセージは無視**される
- これにより、開発時には`DEBUG`レベルで詳細なログを出力し、本番環境では`INFO`や`WARNING`レベルに設定して、必要な情報のみを記録するといった使い分けが簡単に実現できる

### `logging`モジュールからログを扱う

- `logging`モジュールを使ってログを出力する最も簡単な方法は、**`logging.basicConfig()`関数**で基本的な設定を行い、各ログレベルに対応したメソッドを呼び出すこと

**ログを出力する方法**
1. **`logging.basicConfig()`で設定**
- 最初に、**`logging.basicConfig()`** を呼び出して、ログの出力先、ログレベル、フォーマットなどの**基本的な設定**を行う
  - この関数は、プログラム内で一度だけ呼び出す必要がある

```python
import logging

# ログレベルをINFOに設定し、ファイルに出力する例
logging.basicConfig(level=logging.INFO, filename='app.log', format='%(asctime)s - %(levelname)s - %(message)s')
```

- **`logging.basicConfig()`** を一度呼び出すと、**それ以降の呼び出しは無視**される

2. **ログ出力メソッドの呼び出し:**
- 設定後、以下のメソッドを使ってログを出力する
  - `logging.debug('デバッグメッセージ')`
  - `logging.info('情報メッセージ')`
  - `logging.warning('警告メッセージ')`
  - `logging.error('エラーメッセージ')`
  - `logging.critical('致命的エラーメッセージ')`
- メッセージは、**`basicConfig()`で設定したログレベル以上のものだけが出力**される

**`logging.basicConfig()`の主な引数**
- **`filename`**：
  - ログの出力先となる**ファイル名**を指定
    - この引数を指定すると、ログはコンソールではなく、指定したファイルに出力される
  - **注意**：
    - `filename`と`stream`は同時に指定できない

<br>

- **`filemode`**：
  - `filename`で指定したファイルを開くモードを指定
    - `'a'` (append): 
      - ログをファイルの末尾に**追記**（デフォルト）
    - `'w'` (write): 
      - ログをファイルに**上書き**

<br>

- **`format`**：
  - ログメッセージの出力**形式**を指定
  - `'%(asctime)s - %(levelname)s - %(message)s'`のように、フォーマット文字列を使ってカスタマイズできる

<br>

- **`datefmt`**：
  - `format`内の`%(asctime)s`の**日付と時刻の形式**を指定
    - 例： `'Y%-%m-%d %H:%M:%S'`

<br>

- **`style`**：
  - `format`引数で指定するフォーマット文字列のスタイルを指定
  - `'%'`： 
    - デフォルト。`%(...)s`形式を使う

  - `'{'` ：
    - `str.format()`形式 (`{name}`, `{levelname}`など) を使う

  - `'$'`：
    - `string.Template`形式 (`$name`, `$levelname`など) を使う

<br>

- **`level`**：
  - **ルートロガーのログレベル**を設定
    - `logging.INFO`や`logging.DEBUG`などを指定
      - このレベル以上の深刻度を持つメッセージが出力される

<br>

- **`stream`**：
  - ログの出力先となる**ストリーム**を指定
  - デフォルトは`sys.stderr`（標準エラー出力、つまりコンソール）
  - `stream`を指定すると、`filename`は無視される

<br>

- **`handlers`**：
  - `logging.Handler`インスタンスのリストを指定
    - これにより、**複数の出力先（コンソール、ファイルなど）を同時に設定**できる
  - **注意**：
    - `handlers`が指定されている場合、`filename`, `stream`, `level`, `format`, `datefmt`といった他の設定引数は**無視される**

<br>

- **`force`**：
  - ロガーのハンドラーを**強制的に再設定**する
  - `True`を指定すると、`basicConfig()`が既に設定済みであっても、**既存のハンドラーをすべて削除して再設定**する
    - これにより、スクリプトの複数回実行などで設定が重複するのを防げる

<br>

- **`encoding`**： 
  - `filename`で指定したファイルへのログ出力時に使用する**文字コード**を指定
    - 例: `'utf-8'`

<br>

- **`errors`**：
  - `encoding`で指定したエンコーディングでエラーが発生した場合の動作を指定
  - 例: `'ignore'`, `'replace'`など

**ログフォーマット使える属性**

  - **`logging.basicConfig()`** や **`logging.Formatter`** の **`format`引数** で、以下の属性を **`%(属性名)s`** の形式で指定することで、ログメッセージに出力できる

<br>

- **`%(asctime)s`**：
  - **ログが出力された時刻**を文字列で出力
    - デフォルトの形式は`YYYY-MM-DD HH:MM:SS,sss`
    - `datefmt`引数を使って形式をカスタマイズできる

<br>

- **`%(filename)s`**：
  - ログ出力を行ったソースコードの**ファイル名**（拡張子を含む）を出力
    - 例：`main.py`

<br>

- **`%(funcName)s`**：
  - ログ出力を行った**関数名**またはメソッド名を出力

<br>

- **`%(levelname)s`**：
  - ログレベル名を出力
    - `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`のいずれか

<br>

- **`%(lineno)s`**：
  - ログ出力を行ったソースコードの**行番号**を出力

<br>

- **`%(module)s`**：
  - ログ出力を行ったソースコードの**モジュール名**（ファイル名から`.py`を除いたもの）を出力
    - 例: `main`

<br>

- **`%(message)s`**：
  - ログとして渡された**メッセージ本体**を出力
    - これがログの主たる内容

<br>

- **`%(name)s`**：
  - `Logger`インスタンスの**名前**を出力
    - `logging.getLogger('my_app')`とした場合、`my_app`が出力される

<br>

- **`%(pathname)s`**： 
  - ログ出力を行ったソースコードの**完全なパス**を出力
    - 例: `/path/to/my_app/main.py`

<br>

- **`%(process)s`**：
  - ログ出力を行った**プロセスのID**を出力

<br>

- **`%(thread)s`**：
  - ログ出力を行った**スレッドのID**を出力

**例：logger_module.py**


### モジュール方式でロギングを設定する

- ロギングをより柔軟に設定するには、**モジュール方式**（ロガー、ハンドラー、フォーマッターの各オブジェクトを**個別に設定**し、組み合わせて使用する方法）が不可欠
- この方法を使えば、**`basicConfig()`では実現できない複雑なロギング構成**を構築できる

**ロギングの構成要素**
- モジュール方式で設定を行うには、4つの主要なコンポーネントを理解する必要がある

1. **ロガー (`Logger`)：**
  - **ログメッセージの入り口となるオブジェクト**
  - ロガーごとに固有の名前を持ち、階層構造（例: `my_app`, `my_app.sub_module`）を持つことができる

  - ロガーの **`level`** は、**どの深刻度以上のメッセージを受け付けるか**を制御する

2. **ハンドラー (`Handler`)：**
- ロガーが**受け取ったメッセージをどこに出力**するかを決定する
  - 例： 
    - `StreamHandler`（コンソールに出力）
    - `FileHandler`（ファイルに出力）
- ハンドラーにも`level`を設定でき、**ロガーのレベルを通過したメッセージをさらにフィルター**できる

3. **フォーマッター (`Formatter`)：**
- **ログメッセージの出力形式**（フォーマット）を定義
  - `%(asctime)s - %(levelname)s - %(message)s`のような文字列でフォーマットを設定する

4. **フィルター (`Filter`)：**
- ロガーやハンドラーに適用し、**特定の条件を満たすメッセージのみを通過**させる
  - 例えば、**特定のキーワードを含むメッセージのみを出力する**といった設定が可能

**モジュール方式での設定方法**

1. **1つのロガーに複数のハンドラーを設定する**
- 1つのロガーから、**異なる出力先**（例: コンソールとファイル）に**同じログを出力**したい場合に有効

**例：logger_multi_handler.py**

2. **2つのロガーにそれぞれ別のハンドラーを設定する**
- アプリケーションの**異なる部分**（例: ユーザー認証とデータベース操作）ごとに、**異なるログ設定**をしたい場合に有効

**例：logger_another_handler.py**

**フィルターの追加**
- フィルターは、ロガーやハンドラーの **`addFilter()`メソッドを使って追加** する

**例：logger_filter.py**

**ロガーの階層構造**
- ロガーは、ドット`.`で区切られた名前によって**階層的なツリー構造**を形成する
  - これはPythonのパッケージやモジュールの構造と似ている
 
**ルートロガー：**
- すべてのロガーの頂点に位置するロガーで、名前がない（`''`）
  - `logging`モジュールで**直接ログ出力関数**（例：`logging.info()`）**を呼び出す**とこのルートロガーが使われる
  - `logging.basicConfig()`は、このルートロガーの設定を行う

**子ロガーと親ロガー：**
  - `'my_app'`というロガーは、**ルートロガーの子**
  - `'my_app.sub_module'`というロガーは、`'my_app'`という**ロガーの子**であり、**ルートロガーの孫**にあたる

- この場合、`'my_app'`が`'my_app.sub_module'`の**親ロガー**となる。

**ログの伝播 (Propagation)**
- ログメッセージは、ロガーの階層を**上に向かって伝播**していく
1. あるロガー（例: `'my_app.sub_module'`）でログメッセージが出力されると、**そのロガーのハンドラーによって処理**される

2. ロガーの **`propagate`属性が`True`** （デフォルト値）の場合、メッセージは次に**親ロガー（例: `'my_app'`）に渡される**

3. このプロセスは、**メッセージがルートロガーに到達するまで**繰り返される

- これにより、**子ロガーで出力されたログ**が、**親ロガーに設定されたハンドラーでも処理**されるようになる

  - 例えば、`'my_app'`ロガーにファイル出力のハンドラーを設定しておけば、**`'my_app.sub_module'`で出力されたログもそのファイルに記録**される

**`logging.getLogger(name=None)`**
- `logging.getLogger()`は、**指定した名前のロガーインスタンスを取得**する関数

- 引数`name`を省略するか、`None`を指定すると**ルートロガー**を取得
- 引数`name`に文字列を指定すると、その名前のロガーを取得
  - 同じ名前で複数回呼び出しても、常に**同じロガーインスタンス**が返される
- これにより、モジュールをまたいで同じロガーにアクセスできる

**`__name__`の使用**
- 慣習として、`logging.getLogger(__name__)`と記述することが推奨されている
  - `__name__`は、**現在のモジュールの名前を格納**する組み込み変数
  - これにより、**各モジュールが自身の名前を持つロガーを取得**でき、ログメッセージに**どのモジュールから出力されたか**という情報（`%(name)s`）を自動的に付加できる

- 階層的な命名規則に従うことで、`my_app.py`モジュールでは`my_app`ロガーを、`my_app/sub.py`モジュールでは`my_app.sub`ロガーを取得でき、ロガーの階層構造を自然に構築できる

**例：my_appディレクトリ**

### 辞書やファイルからロギングを設定する

- `logging`モジュールの設定は、`basicConfig()`のようにコード内で直接行うだけでなく、**辞書（`dict`）やファイル**から読み込んで設定することもできる
  - これにより、ロギング設定をアプリケーションのコードから分離し、外部ファイルとして管理できるようになる

**辞書から設定する方法 (`dictConfig`)**
- `logging.config.dictConfig()`関数を使用すると、**Pythonの`dict`オブジェクトからロギング設定を読み込む**ことができる
  - これは、JSONやYAMLファイルで設定を管理したい場合に特に便利

**設定辞書の構造**
- 設定辞書には、通常以下のキーが含まれる
<br>

- `version`：
    - 必須
    - 辞書スキーマのバージョンを指定
      - 現在は`1`
<br>

- `disable_existing_loggers`： 
  - `True`にすると、**既存のロガーをすべて無効**にする
    - デフォルトは`True`
<br>

- `formatters`： 
  - フォーマッターを定義する辞書
<br>

- `filters`：
  - フィルターを定義する辞書
<br>

- `handlers`： 
  - ハンドラーを定義する辞書
<btr>

- `loggers`：
  - ロガーを定義する辞書

**例：logger_dictconfig.py**

**ファイルから設定する方法 (`fileConfig`)**
- **`logging.config.fileConfig()`** 関数は、**`INI`形式**のファイルからロギング設定を読み込む
- これは、Pythonの標準ライブラリの`configparser`モジュールに準拠した形式

**例：logger_fileconfig.py**

**`dictConfig`と`fileConfig`の比較**

| **特徴** | **`dictConfig`** | **`fileConfig`** |
| --- | --- | --- |
| **形式** | Pythonの辞書（JSON, YAMLから変換可能） | INIファイル |
| **柔軟性** | **高い**。クラスパスの指定など、より高度な設定が可能。 | 比較的シンプル。`INI`形式の制約を受ける。 |
| **推奨** | **新しいコードでは推奨**。柔軟で拡張性が高いため。 | シンプルな設定には十分。過去のコードでよく見られる。 |