## 18.1 安全な乱数を生成する `secrets`

- Pythonの`secrets`モジュールは、**暗号学的に安全なランダムな値**を生成するために設計された標準ライブラリ
- パスワード/認証トークン/セキュリティキーなど、**セキュリティを要する用途**に特化している
- このモジュールが重要な理由は、**通常の`random`モジュールが生成する値は予測可能**のため、セキュリティ上の目的には適さない
    - `secrets`モジュールは、オペレーティングシステムが提供する**セキュアな乱数生成器**を利用しており、その結果は推測困難

### パスワード（乱数）の生成

**`secrets.choice()`関数**
- `secrets.choice()`は、`secrets`モジュールで提供される関数の一つで、**シーケンス（リスト、タプル、文字列など）** から暗号学的に安全な**ランダムな要素を一つ選択**する

```python
secrets.choice(sequence)
```
- **`sequence`**：
  - 要素を選択する対象となるシーケンス。

**`secrets.choice()`の主な用途**
- **パスワード生成**：
  - 許可された文字セット（大文字、小文字、数字、記号など）からランダムに文字を選び、パスワードを作成する
- **トークン生成**：
  - 認証トークンやリセットリンクのIDなど、一意で推測されにくい値を生成する際に使用される
- **検証コード**：
  - SMSやメールで送信される使い捨ての認証コードを生成する

**`secrets.choice()`と`random.choice()`の違い**

| **特徴** | **`secrets.choice()`** | **`random.choice()`** |
| --- | --- | --- |
| **用途** | **セキュリティを要する場面**（パスワード、トークンなど） | **一般的な用途**（ゲーム、シミュレーションなど） |
| **安全性** | **暗号学的に安全**。推測困難な値 | 暗号学的には**安全ではない**。シード値を知ると予測可能 |
| **速度** | `random`モジュールより**わずかに遅い**。 | `secrets`モジュールより**高速** |

### トークンの生成
- `secrets`モジュールの **`token_bytes()`** , **`token_hex()`** , **`token_urlsafe()`** はそれぞれ異なる形式で**安全なランダムな値を生成**するための関数
- これらは認証トークンやパスワードリセットトークンなどのセキュリティ目的で広く使用される

1.  **`secrets.token_bytes([nbytes=None])`**
- `secrets.token_bytes()`は、**ランダムなバイト列**を生成する
- **引数**：
  - `nbytes`は**生成するバイト数**を指定
    - 省略すると、デフォルトのバイト数が使用される
- **戻り値**： 
  - **`bytes`型**のオブジェクト
- **主な用途**：
  - バイナリデータを必要とする暗号化キーやランダムなシード値など、**生のバイトデータが求められる**場面に適している

2. **`secrets.token_hex([nbytes=None])`**
- `secrets.token_hex()`は、ランダムな**バイト列**を**16進数（hex）の文字列に変換**して生成
- **引数**： 
  - `nbytes`は**バイト数**を指定
    - `nbytes=32`を指定すると、結果の文字列の長さは`32 * 2 = 64`文字になる
- **戻り値**：
  - **16進数文字列**（`str`型）。
- **主な用途**：
  - データベースに保存するトークンや、URLに含めないAPIキーなど、人間が読める形式で、かつ安全なランダム文字列が必要な場合に適している

3. **`secrets.token_urlsafe([nbytes=None])`**
- `secrets.token_urlsafe()`は、**URLやファイル名に安全に含めることができる**ランダムな文字列を生成
- **引数**：
  - `nbytes`は**バイト数**を指定
    - 生成される文字列の長さは、バイト数よりも長くなる（約1.3倍）
- **戻り値**：
  - URLセーフな文字列（`str`型）
- **主な用途**：
  - パスワードリセットリンク、メール認証トークンなど、**URLに直接含める必要があるトークンを生成**する場合に最適
    - 生成される文字列には、`+`, `/`などの**特殊文字が含まれず**、, `_`といったURLに安全な文字が使用される

**比較まとめ**

| **関数** | **形式** | **主な用途** | **特徴** |
| --- | --- | --- | --- |
| **`token_bytes()`** | **バイト列(`bytes`)** | 暗号化キー、バイナリデータ | **生のバイトデータが必要**な場合 |
| **`token_hex()`** | **16進数文字列 (`str`)** | APIキー、データベーストークン | 視認性が高く、URLに含めない場合 |
| **`token_urlsafe()`** | **URLセーフな文字列 (`str`)** | URLトークン、ファイル名 | URLにそのまま使用できる |

**`secrets.compare_digest()`**
- Pythonの **`secrets.compare_digest()`** は、2つのバイト列または文字列が**等しいか**どうかを**タイミング攻撃のリスクなく**安全に比較するための関数
- 主にパスワードのハッシュ値や認証トークンなどを検証する際に使用される

>### **タイミング攻撃とは**
>通常の`==`演算子で文字列を比較する場合、Pythonは文字を**先頭から順に比較**し、
**不一致が見つかった時点で直ちに比較を終了**する
>- `'password' == 'password'` 
>   - 全ての文字を比較するため、時間がかかる
>- `'password' == 'pazsword'` 
>   - 3文字目で不一致が見つかり、すぐに終了するため、時間がかからない
>
> このように比較にかかる時間が変動すると、攻撃者は**この時間の差を精密に計測**することで、**推測したパスワードが正しいパスワードと何文字一致しているか**を知る手がかりを得てしまうのが**タイミング攻撃**という

**`secrets.compare_digest()`の仕組み**
- `secrets.compare_digest()`は、このタイミング攻撃を防ぐために、2つの文字列またはバイト列の**すべての文字を常に最後まで比較する**
- **等しい場合**： 
  - 全ての文字を比較し、最終的に **`True`を返す**
- **等しくない場合**： 
  - 全ての文字を比較し、最終的に **`False`を返す**
- どちらの場合でも、比較にかかる時間は**ほぼ一定**になる
    - これにより、攻撃者は検証時間から有効な情報を得ることができず、セキュリティが向上する

**例：secrets_module.py**

## 18.2 ハッシュ地を生成する `hashlib`

- `hashlib`モジュールは、**様々なハッシュアルゴリズム**をPythonで実装するための標準ライブラリ
- **データのハッシュ値を計算**する機能を提供し、
データの完全性検証やパスワードの保存などに使われる

**`hashlib`モジュールの基本**
- `hashlib`モジュールは、主に以下の3つのステップでハッシュ値を計算する

1. **アルゴリズムの選択**
- **`hashlib.sha256()`** のように、使用したいハッシュアルゴリズムに対応するコンストラクタを呼び出す
2. **データの更新**
- **`update()`**メソッドを使い、ハッシュ計算対象のデータを**バイト列**として与える
  - `update()`は**複数回呼び出す**ことができ、**大きなデータを分割して処理**するのに便利

3. **ダイジェスト（ハッシュ値）の取得：**
- **`hexdigest()`**：
  - ハッシュ値を**16進数文字列で返す**
    - 一般的にこちらがよく使われる
- **`digest()`**：
  -  ハッシュ値を生**のバイト列で返す**

### 様々なアルゴリズムを使用したハッシュ値算出

**`hashlib.algorithms_available`**

- `hashlib.algorithms_available`は、現在のPython環境で**利用可能なすべてのハッシュアルゴリズム**の名前を格納した **`set`オブジェクト**
  - この属性は、`hashlib`モジュールがサポートする**ハッシュアルゴリズムのリスト**を動的に提供
- Pythonのビルド方法や、実行環境にインストールされているライブラリ（OpenSSLなど）によって利用できるアルゴリズムが異なる場合があるため、この属性で確認することが重要
- `hashlib`モジュールは、`md5`や`sha256`のような**特定のアルゴリズムを直接呼び出すための関数を提供**しているが、**動的にアルゴリズム名からハッシュオブジェクトを生成したい**場合にもこの情報が役立つ

<br>

`hashlib`モジュールにおける **`update()`**, **`digest()`**, **`hexdigest()`** は、ハッシュ値を計算する際のコアとなる3つのメソッド
- これらはセットで使われることが多く、データのハッシュ値を効率的に計算するために設計されている

**`update()`**
- `update()`は、ハッシュオブジェクトに**データを追加**するためのメソッド
- **機能**： 
  - ハッシュ計算の対象となる**バイト列**を**ハッシュオブジェクト**に渡す
- **引数**：
  - 必ず**バイト列 (`bytes`)でデータを渡す**必要がある
    - 文字列を渡す場合は、`'hello'.encode('utf-8')`のように**エンコードが必要**
- **特徴**：
  - `update()`は**複数回呼び出す**ことができる。
    - これにより、メモリに収まらないような大きなファイルを少しずつ読み込んでハッシュ計算を行うことができる
    - 各呼び出しで追加されたデータは、**前のデータに続いてハッシュ化**される

**`digest()`**
- `digest()`は、これまでに`update()`で追加されたデータの**ハッシュ値**を**生のバイト列**として返す
- **機能：** 
  - **ハッシュ計算の結果**を取得する
- **戻り値**： 
  - **`bytes`型**のオブジェクト
- **特徴**：
  - `digest()`を呼び出した後も、ハッシュオブジェクトはそのまま残っており、**さらに`update()`でデータを追加することができる**
    - ただし、`digest()`や`hexdigest()`を複数回呼び出すと、**常に同じ結果が返る**

**`hexdigest()`**
- `hexdigest()`は、`digest()`と同じくハッシュ値を返すが、**形式が異なる**
- **機能**：
  - ハッシュ計算の結果を**16進数文字列**として返す
- **戻り値**： 
  - `str`型のオブジェクト
- **特徴：**
  - 一般的に、`digest()`よりもこちらがよく使われる
    - ログに出力、データベースに保存、ユーザーに表示する場合に便利
    - `digest()`と同様に、**呼び出し後もハッシュオブジェクトは変更されない**

これらのメソッドは、以下のフローで動作する
1. `hasher = hashlib.sha256()` で**ハッシュオブジェクトを初期化**する
2. `hasher.update(data)` で**データを追加**
   - これは必要なだけ繰り返せる

3. `hasher.hexdigest()` または `hasher.digest()` で**ハッシュ値を取得**する

- 簡潔にハッシュ値を計算したい場合は、以下のショートカットも使用できる。

```python
import hashlib

# 1行でハッシュ値を計算
hash_string = hashlib.sha256(b'hello').hexdigest()
print(hash_string)
```

**主なハッシュアルゴリズムのハッシュ値の長さと概要**

| **アルゴリズム** | **`hashlib`メソッド** | **`digest()`バイト長** | **概要と推奨度** |
| --- | --- | --- | --- |
| **MD5** | `hashlib.md5()` | 16 | **非推奨** <br> 過去に広く使われたが、衝突攻撃に脆弱 <br> データの完全性チェックなど、セキュリティを求めない用途のみに限定すべき。 |
| **SHA-1** | `hashlib.sha1()` | 20 | **非推奨** <br> MD5より強力だが、同様に衝突攻撃に脆弱性が確認されている <br> 新規のアプリケーションでは使用すべきではない|
| **SHA-256** | `hashlib.sha256()` | 32 | **推奨** <br> 現在の業界標準 <br> 高いセキュリティを持ち、TLS/SSL、暗号通貨、データの完全性検証など、幅広い用途で利用されている |
| **SHA-512** | `hashlib.sha512()` | 64 | **推奨** <br> SHA-256より長いハッシュ値を生成し、64ビットシステムで特に高速 <br> SHA-256より高いセキュリティが求められる場合に適している |
| **SHA3-512** | `hashlib.sha3_512()` | 64 | **推奨** <br> SHA-2とは全く異なる設計を持つ新しいアルゴリズム <br> SHA-2の将来的な脆弱性に備えた代替として開発された |
| **BLAKE2b** | `hashlib.blake2b()` | 64 | **推奨** <br> SHA-3の有力な代替として注目されている <br> SHA-2よりも高速で高いセキュリティを持つ <br> パフォーマンスが重要な場面で有用|

**例：hashlib_module.py**

### `hashlib`による鍵導出関数

- `hashlib`モジュールは、直接的なハッシュアルゴリズムを提供するだけでなく、パスワードのような**機密情報から安全に鍵を導出**するための
**鍵導出関数 (KDF: Key Derivation Function)** も提供している

> ### 鍵導出関数 (KDF)
>- 鍵導出関数は、パスワードなどの短い、推測されやすい入力から、**暗号化に適した長くてランダムな鍵を生成**するアルゴリズム
> - 主な目的は**パスワードクラッキング（総当たり攻撃など）への耐性を高める**こと
> - パスワードを直接ハッシュ化するだけでは、高速な計算機を使えば短時間で多数のパスワード候補を試行されてしまう
> - KDFは、この計算に意図的に**時間とリソースを消費させる**ことで、攻撃を困難にする

**`pbkdf2_hmac()`**
- `hashlib`が提供する最も一般的な鍵導出関数が **`pbkdf2_hmac()`**
  - これは、**PBKDF2 (Password-Based Key Derivation Function 2)** という標準アルゴリズムを実装している

```python
hashlib.pbkdf2_hmac(hash_name, password, salt, iterations, dklen=None)
```

**引数の詳細**
- **`hash_name`**：
  - 鍵導出に使用するハッシュアルゴリズムの名前（例: `'sha256'`, `'sha512'`）
- **`password`**：
  - ユーザーが入力したパスワード
    - バイト列 (`bytes`)で指定
- **`salt`**： 
  - 鍵導出のランダム性を高めるための**ソルト**。
    - ソルトはパスワードごとに一意のランダムな値で、**攻撃者が事前に計算した辞書（レインボーテーブル）を使用するのを防ぐ**。
    - これも**バイト列**で指定
- **`iterations`**：
  - **ハッシュ計算を繰り返す回数**
    - この値が大きいほど計算に時間がかかり、総当たり攻撃への耐性が高まる
  - この値は、ハードウェアの進化に合わせて定期的に更新すべき
    - 目安として、現代のコンピューターで約**数百ミリ秒から1秒**かかるように設定するのが良いとされている

- **`dklen`**： 
  - 導出される鍵の長さ（バイト単位）
    - 省略すると、`hash_name`で指定したハッシュアルゴリズムのハッシュ値の長さになる

**例：hashlib_kdf.py**