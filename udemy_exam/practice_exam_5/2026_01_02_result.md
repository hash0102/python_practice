### 次のコードの出力として 正しいものはどれか。


```python
from datetime import datetime, timezone, timedelta

dt1 = datetime(2025, 12, 16, 14, 30, 15)

dt2 = datetime(2025, 12, 16, 23, 30, 15,tzinfo=timezone(timedelta(hours=9)))

iso = dt1.isoformat()
fmt = dt1.strftime("%Y/%m/%d %H:%M:%S")
weekday = dt1.weekday()
utcoffset = dt2.utcoffset()
tzname = dt2.tzname()

print(iso)
print(fmt)
print(weekday)
print(utcoffset)
print(tzname)
```

1. 
```python
2025-12-16T14:30:15
2025/12/16 14:30:15
1
None
None
```

2. 
```python
2025-12-16T14:30:15
2025/12/16 14:30:15
1
9:00:00
UTC+09:00
```

3. 
```python
2025-12-16 14:30:15
2025/12/16 14:30:15
7
9:00:00
UTC+09:00
```

4. 
```python
2025-12-16T14:30:15
2025/12/16 14:30:15
7
9:00:00
None
```

**回答**
```bash
2025-12-16 14:30:15
2025/12/16 14:30:15
7
9:00:00
UTC+09:00
```

**正解**
```bash
2025-12-16T14:30:15
2025/12/16 14:30:15
1
9:00:00
UTC+09:00
```

**解説**
```python
from datetime import datetime, timezone, timedelta
```
- `datetime`：
  - 日付・時刻オブジェクトを作るため

- `timezone`：
  - **UTCオフセット付きのタイムゾーン**を扱う(JSTはUTC+9)
- `timedelta`：
  - 時間差（オフセットや計算用）を表す

```python
dt1 = datetime(2025, 12, 16, 14, 30, 15)
```

- 年月日・時分秒を指定して **`naive`** な `datetime`を生成 
  - `naive` な `datetime`なので、**タイムゾーン情報なし(`tzinfo=None`)**

```python
dt2 = datetime(2025, 12, 16, 23, 30, 15, tzinfo=timezone(timedelta(hours=9)))
```
- `UTC+9`(UTCより9時間進んでいる)の**タイムゾーンを持つ** `aware` な `datetime`
- `tzinfo=timezone(timedelta(hours=9))`で指定している
- `dt2`に入っているのは 「日本時間の2025/12/16 23:30:15」

```python
iso = dt1.isoformat()
```

- `isoformat()`：
  - **ISO 8601形式の文字列に変換**

- `dt1`は`naive`なので**オフセットなしで表示**(+09:00などが表示されない)

- オフセットありの場合の例：
  - `2025-12-16T14:30:15+09:00`

```python
fmt = dt1.strftime("%Y/%m/%d %H:%M:%S")
```

- `strftime()`：
  - 任意フォーマットで文字列化
  - `%Y 年、%m 月、%d 日、%H 時、%M 分、%S 秒`

```python
weekday = dt1.weekday()
```
- `weekday()` ：
  - 曜日を**整数で返す**（0=月曜、6=日曜）
  - 2025-12-16 は火曜日 → 1


```python
utcoffset = dt2.utcoffset()
```
- `aware datetime` の **UTCオフセット を取得**
- dt2 は **UTC+9**
  - `timedelta(hours=9)`
  - 出力例： 9:00:00

```python
tzname = dt2.tzname()
```

- `aware datetime` の **タイムゾーン名 を取得**

- `datetime.timezone` の場合は **"UTC+09:00" が自動生成**される

※Python実践レシピ:日付と時刻の処理

### 次のコードを実行したとき、出力される結果として 正しいもの はどれか。

```python
from datetime import time

t = time(14, 30, 15)
iso_str = t.isoformat()
t2 = time.fromisoformat("14:30:15")
formatted = t.strftime("%H時%M分%S秒")
tz = t.tzname()

print(iso_str)
print(t2)
print(formatted)
print(tz)
```

1. 
```bash
14:30:15
14-30-15
14時30分15秒
None
```

2. 
```bash
14:30:15
14:30:15
14:30:15
None
```

3. 
```bash
14:30:15
14:30:15
14時30分15秒
None
```

4. 
```bash
14-30-15
14:30:15
14:30:15
UTC
```

**回答**
```bash
14:30:15
14-30-15
14時30分15秒
None
```

**正解**
```bash
14:30:15
14:30:15
14時30分15秒
None
```

**解説**
`isoformat()`
- `time` オブジェクトを **ISO 形式** `"HH:MM:SS"` の文字列に変換
  - **`"14:30:15"`**

`fromisoformat()`
- ISO形式の文字列 `"HH:MM:SS"` から **time オブジェクトを生成**
  - t2 は 14:30:15

`strftime(fmt)`
- 指定フォーマットに変換
- **"%H時%M分%S秒"**
  - "14時30分15秒"

`tzname()`
- tzinfo がない場合は **`None`**
- t はタイムゾーンなし → None

**※補足**

**ISO形式とは？**
- 国際標準化機構（ISO: International Organization for Standardization）が定めた標準的な日付・時刻の表記形式 のこと
- 日付：**YYYY-MM-DD** の形式で表す
- 時刻：**HH:MM:SS** の形式で表す

**`tzinfo`**
- datetime, time, datetime.timezone などに設定できる**タイムゾーン情報を保持する属性**

- デフォルトでは datetime や time は `tzinfo=None`(**この状態を naiveという**)

- 明示的に `tzinfo`を指定するか、ISO 形式文字列に UTC オフセットがある場合はaware(タイムゾーン情報を持つ状態)となる。aware と naive は計算に混ぜて使えない

※Python実践レシピ:日付と時刻の処理

### 次のコードを実行したとき、出力される結果として 正しいもの はどれか。

```python
num = 10
s = "{0:-^5o} -> {0}".format(num)
print(s)
```

```python
1. -12-- -> 10

2. --12- -> 10

3. 12--- - 10

4. 12 - 10
```

**回答**
`-12-- -> 10`

**正解**
`--12- -> 10`

**解説**
`{0:-^5o}`
- `0`
  - `format`の0番目の引数（`num`）
- `o` 
  - **8進数に変換**　(num = 10 → 8進数 → 12)
- `:-^5o` 
  - 幅5、中央寄せ、埋め文字 -(出力 → "--12-")


`{0}`
- 10進数そのまま → "10"

`format(num)`

- `str.format()` は、Pythonの文字列フォーマットメソッドの1つで、文字列中の `{}` に値を埋め込むために使う

**※補足**
`->`は文字列

[出力結果]

`--12- -> 10`

※Python実践レシピ:テキストの処理

### 次のPythonコードを実行したとき、出力結果として正しいのはどれか

```python
text = "///  Python  ///"

result = text.removeprefix("///").lstrip().rstrip("/")

print(result)
```

```python
1. "Python ///"
2. "Python "
3. "Python"
4. " Python"
```

**回答**
`"Python ///"`

**正解**
`"Python "`

**解説**
`removeprefix("///")`　
- 文字列の先頭にある **`"///"` を削除**

→ `"  Python  ///"`



`lstrip()`　
- **先頭の空白文字**をすべて削除

→ `"Python  ///"`



`rstrip("/")`　
- 末尾の `/` を**すべて削除**

→ `"Python  "`

※Python実践レシピ:テキストの処理

### 次のコードを実行したとき、表示される結果として 正しいもの はどれか。

```python
a = 5
b = 3
print(f"{a=} {b=} {a+b=}")
```

```python
1. a=5 b=3 8
2. 5 3 8
3. a:5 b:3 a+b:8
4. a=5 b=3 a+b=8
```

**回答**
`a=5 b=3 8`

**正解**
`a=5 b=3 a+b=8`

**解説**
- `f-string` とは、Python 3.6 以降で使える「文字列フォーマットの方法」の1つで、
- 文字列中に 変数や式の値を直接埋め込むことができる文字列リテラル のことです。



**f-string の `=` 記法　`f"{変数=}"`**
- 変数名とその値を `変数名=値` の形式で表示できる。

- 計算式　`f"{a+b=}"`
- 式を文字列として評価
- 変数名の代わりに 式全体 を表示



※Python実践レシピ:テキストの処理

### 次のコードを実行したとき、出力される結果として 正しいもの はどれか。

```python
value = 0.256
num = 10

print(f"{value:>8.1%} {num:<5b} {num:04x}")
```

```python
1. "25.6% 1010 000a"
2. "25.6% 1010 000A"
3. "   25.6% 1010 000A"
4. "   25.6% 1010  000a"
```

**回答**
`"   25.6% 1010 000A"`

**正解**
`"   25.6% 1010  000a"`

**解説**
`{value:>8.1%}`

- `>`
  - 右寄せ

- `8` 
  - 全体の幅8文字

- `.1%`
  - 百分率形式、小数点以下1桁

`{num:<5b}`

- `<`
  - 左寄せ

- `5`
  - 幅5文字

- `b` 
  - **2進数（binary）**

`{num:04x}`

- `0`
  - ゼロ埋め

- `4`
  - 幅4

- `x`
  - **16進数（小文字）**

※Python実践レシピ:テキストの処理

### 次のうち、typing モジュールを使った型ヒントとして 誤っているもの はどれか。

1. 
```python
from typing import TypeVar

T = TypeVar("T", int, str)

x: T = 10
y: T = True
```

2. 
```python
from typing import TypedDict

class Person(TypedDict): name: str; age: int

person: Person = {"name": "Alice", "age": 30}
```

3.
```python
from typing import Optional


def greet(name: Optional[str]) -> str:
    return f"Hello {name}"
```

4.
```python
from typing import Union


def greet(name: Union[str, None]) -> str:
    return f"Hello {name}"
```

**回答**
```python
from typing import TypedDict

class Person(TypedDict): name: str; age: int

person: Person = {"name": "Alice", "age": 30}
```

**正解**
```python
from typing import TypeVar

T = TypeVar("T", int, str)

x: T = 10
y: T = True
```

**解説**
`Union[str, None]`
- `Union` は**複数の型を許容**するために使う
- この例では、`name` が `str` または `None` のどちらでも受け入れる

`Optional[str]`
- `Optional[]`は **`[]`内に指定した型とNone**を受け入れる
- この例では、`name` は `str` か `None` を受け入れる

`class Animal(TypedDict): name: str; age: int`
- Animal という **型付き辞書 を定義**
- name は文字列、age は整数という型に指定

`person: Animal = {"name": "Alice", "age": 30}`
- Animal型の辞書を作成

**TypeVarの正しい使い方**

```python
from typing import TypeVar

T = TypeVar("T", int, str)


def repeat_value(value: T, n: int) -> list[T]:
    return [value] * n

result1 = repeat_value(10, 3)
result2 = repeat_value("Hi", 2)
```

- TypeVar は **「型の抽象化」を行う**ためのもの
- 変数に直接代入して型を決めるものではない

`T = TypeVar("T", int, str)`
- ここで定義した T は int または str のいずれか に限定される
- T は**単独の変数の型として使うのではなく**、**関数やクラスで型を抽象化するための記号**として使用

`-> list[T]`
- 戻り値は T 型の要素を持つリスト

`[value] * n`
- Python のリスト操作で、要素 value を n 回繰り返したリストを作成

※Python実践レシピ:型ヒント

### 次のうち、`@staticmethod` の特徴として 誤っているもの はどれか。

```python
1. 静的メソッドは self を受け取らない
2. 静的メソッドは クラス内のユーティリティ関数として整理できる
3. 静的メソッドは クラスやインスタンスの属性に直接アクセスできる
4. 静的メソッドは インスタンスを生成せずクラスから直接呼び出せる
```

**回答**
静的メソッドは self を受け取らない

**正解**
静的メソッドは クラスやインスタンスの属性に直接アクセスできる


**解説**
- 静的メソッドは **状態を持たず独立した処理を行う関数** であり、クラスやインスタンスの**属性に直接アクセスすることはできない。**
- Python では、静的メソッドを作るときに 必ず **`@staticmethod` デコレーターを付ける必要がある**

※Python実践レシピ:Pythonのクラス


### 次のPythonコードを実行したとき、出力結果として正しいのはどれか

```python
text = "###python"

result = text.removeprefix("###").swapcase().capitalize().zfill(10)

print(result)
```

```python
1. "000Python"
2. "1111PYTHON"
3. "Python"
4. "0000Python"
```

**回答**
`"000Python"`

**正解**
`"0000Python"`

**解説**
`removeprefix("###")`　
- 先頭の **`"###"` を削除**

→ `"python"`



`swapcase()`　
- 大文字↔小文字を反転

→ `"PYTHON"`



`capitalize()`　
- 先頭文字を大文字、残りを小文字に変換

→ `"Python"`



`zfill(10)`　
- **文字列の長さが10になるよう左側を 0 で埋める**

→ `"Python"` は**6文字**なので、`"0000Python"`

※Python実践レシピ:テキストの処理

### 次のPythonコードを実行したとき、表示される結果として正しいものはどれか。

```python
import string

result = (
    string.ascii_lowercase[0] +
    string.punctuation[3] +
    string.whitespace[0] +
    string.digits[-1]
)

print(result)
```

```python
1. "a! a"
2. "a$ 9"
3. ":a 9"
4. "ac 9"
```

**解説**
- これはstring モジュールの 文字列定数に関する問題です。

`string.ascii_lowercase`
→ `"abcdefghijklmnopqrstuvwxyz"`
- `[0]` 
  - → `"a"`



`string.punctuation`　
→ `` !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ ``
- `[3]` 
  - → `"$"`



`string.whitespace`　
→ `" \t\n\r\x0b\x0c"`
- `[0] `
  - → 半角スペース `" "`



`string.digits`　
→ `"0123456789"`
- `[-1]` 
  - → `"9"`

`"a" + "$" + " " + "9"`　で`"a$ 9"`となる。

※Python実践レシピ:テキストの処理

### 次のコードを実行したとき、出力される結果として 正しいもの はどれか。

```python
import re

text = "Python3.10 is cool"

pattern = r"\d+"

m1 = re.match(pattern, text)
m2 = re.search(pattern, text)

print(m1)
print(m2.group() if m2 else None)
```

```python
1. 
None
3.10

2. 
<re.Match object ...>
3

3. 
<re.Match object ...>
3.10

4. 
None
3
```

**回答**
```python
<re.Match object ...>
3.10
```

**正解**
```python
None
3
```

**解説**

`re.match(pattern, text)`
- `match()` は **文字列の先頭からパターンがマッチするか** を調べる

- `text = "Python3.10 is cool"` の先頭は `"Python"`

- `\d+` → 連続する**数字**
  - 先頭は数字ではない → **マッチせず `None`**

`re.search(pattern, text)`

- `search()` は **文字列全体を対象に最初のマッチを探す**
- `"Python3.10"` の中で**最初に数字は `3`**
- マッチ結果 → `m2.group()` = `"3"`

`m2.group() if m2 else None`
- `group()`でマッチした文字列を取得できる
- `m2.group()` → `"3"`
- `m2` が `None` でなければ → `m2.group()` を実行

※Python実践レシピ:テキストの処理

### 次のPythonコードの出力として 間違っているもの はどれか。

```python
s1 = "こんにちは"
s2 = "一二三四" 
s3 = "Python3!"
s4 = "Python"

print(s1.isalpha())
print(s2.isnumeric())
print(s3.isalnum())
print(s4.isupper())
```

```python
1. s4.isupper() → False
2. s2.isnumeric() → False
3. s1.isalpha() → True
4. s3.isalnum() → False
```

**正解**
`s2.isnumeric() → False`

**回答**
`s3.isalnum() → False`


**解説**
`isalpha()`
- 文字列が**文字のみか判定**する。
- (記号や数字を含まない**日本語文字列であればTrue**となる)

`isnumeric()`

- 文字列が**数字のみか判定**する。(**漢数字も含む**)

`isalnum()`
- 文字列が**英数字のみか判定**する。

`isupper()`
- 文字列が**大文字のみか判定**する。

※Python実践レシピ:テキストの処理