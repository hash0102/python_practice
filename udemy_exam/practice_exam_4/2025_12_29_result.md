### 次のコードを実行したとき、正しい出力はどれか。


```python
print(list("xyz"))
print(tuple({"a": 1, "b": 2}))
print(dict([("k", 100), ("v", 200)]))
```

```python
1. 
'x', 'y', 'z'
'a', 'b'
'k': 100, 'v': 200

2. 
['x', 'y', 'z']
('a', 'b')
{'k': 100, 'v': 200}

3. 
['xyz']
('a', 'b')
{'k': 100, 'v': 200}

4.
['x', 'y', 'z']
(('a', 1), ('b', 2))
{'k': 100, 'v': 200}
```

**回答**
```python
['xyz']
('a', 'b')
{'k': 100, 'v': 200}
```

**正解**
```python
['x', 'y', 'z']
('a', 'b')
{'k': 100, 'v': 200}
```

**解説**
- `list()` に**文字列**を渡すと、**1文字ずつに分解されたリスト**になる

- `tuple()`に**文字列**を渡すと、**1文字ずつに分解されたタプル**になる
  - 辞書をそのまま反復すると**キーだけ が取り出されます。**

- `dict()`は、`(key, value)` のペアから辞書を作成できる

※辞書はイテラブルだが、イテラブルとしての要素は キー
※Python実践レシピ:コーディング規約

### リスト内包表記よりジェネレータ式のほうが優れている点」として誤りはどれか。

```python
1. ジェネレータ式は途中で処理を停止できるため、大きなデータを扱う場合にも効率的である。

2. ジェネレータ式はイテラブルとして扱えるため、for ループなどでそのまま使用できる。

3. ジェネレータ式は必要なときに1つずつ値を生成するため、メモリ使用量が少ない。

4. ジェネレータ式は全ての値を一度に計算するため、計算速度がリスト内包表記より速い。
```

**回答**
ジェネレータ式は途中で処理を停止できるため、大きなデータを扱う場合にも効率的である。

**正解**
ジェネレータ式は全ての値を一度に計算するため、計算速度がリスト内包表記より速い。

**解説**
- ジェネレータ式の強みは：
  - メモリ効率が良い  
  - 遅延評価で必要なときだけ計算
  - 大規模データや無限列に向いている
  - `for` ループで自然に使える
- ただし “全部を即計算する” わけではなく、リスト内包表記より計算速度が速いとは限らない。

※Python実践レシピ:コーディング規約

### 次のコードを実行したとき、出力として正しいものはどれか。

```python
gen = (x**2 for x in range(3))

print(next(gen))
print(next(gen))
print(next(gen))
print(next(gen, 'end'))
```

1. 
```python
0
1
4
StopIteration
```

2. 
```python
0
1
4
'end'
```

3. 
```python
1
4
9
'end'
```

4. 
```python
0
1
2
'end'
```

**回答**
```python
0
1
4
StopIteration
```

**正解**
```python
0
1
4
'end'
```

**解説**
1. ジェネレーターの内容
```python
gen = (x**2 for x in range(3))
```
- `range(3)` 
  - `[0, 1, 2]`

- 各要素を2乗
  - `0, 1, 4`

- `gen`は`generator`（順番に値を生成するイテレータ）

2. `next()`で順番に値を取り出す

```python
print(next(gen))  # 0
print(next(gen))  # 1
print(next(gen))  # 4
```
- 1つずつ値を取り出すたびに内部の位置が進む

3. `next()` の `default` パラメータ
```python
print(next(gen, 'end'))
```
- ジェネレーターはもう要素がない
- **`default='end'` が指定されている**ので `StopIteration` ではなく `'end'` を返す

`default`（省略可能）：**イテレータが尽きたとき返す値**

※Python実践レシピ:コーディング規約

### 次のコードを実行した場合、出力されるものはどれか。

```python
class MyError(Exception):
    pass

try:
    raise MyError("独自例外発生")
except ValueError:
    print("値エラーを捕捉")
except TypeError:
    print("型エラーを捕捉")
except Exception:
    print("一般的な例外を捕捉")
except MyError:
    print("独自例外を捕捉")
```

```python
1. 独自例外を捕捉
2. 一般的な例外を捕捉
3. 値エラーを捕捉
4. エラーが出るため何も出力されない
```

**回答**
独自例外を捕捉

**正解**
一般的な例外を捕捉

**解説**

```python
class MyError(Exception):
    pass
```

- `MyError` は **`Exception` のサブクラス**

- `raise MyError(...)` で `MyError` を発生させることができる

- `except Exception` 
  - `MyError` は **`Exception` のサブクラスなのでここで捕捉**

### 次のコードを実行すると、出力として正しいものはどれか。

```python
data = (1, 2, 3, 4)
a, *b, c = data
print(a, b, c)
```

```python
1. 1 [2, 3] 4
2. 1, 2, 3 4
3. 1 (2, 3) 4
4. 実行時にエラーが発生する
```

**回答**
`1 (2, 3) 4`

**正解**
`1 [2, 3] 4`


**解説**
- アンパックの仕組み
  - Pythonでは、`*`を使うと 複数の値をまとめて**1つのリストとして受け取れる。**

- `a, *b, c = data` の場合：
  - `a` → 最初の要素 1
  - `c` → 最後の要素 4
  - `*b` → 残りの中間要素 [2, 3] が **リストとして まとめられる**

- `*b` の結果は **タプルではなくリス**ト になる

Pythonのアンパックでは**中間の `*` は常にリストにまとめられる**


**※注意点**
- `* `は **1つだけ の変数に使える**（同じ行に複数 * は不可）
- 最初や最後、途中のどこでも使える

※Python実践レシピ:コーディング規約

### 次のコードに対して Flake8 が指摘するエラーコードはどれか。

```python
import math
print("hello")
```

```python
1. F401
2. F821
3. E305
4. E501
```

**回答**
`E501`

**正解**
`F401`

**解説**
- `import math` が 使われていないので、
- `F401: module imported but unused`が発生する。

**Flake8に含まれる静的コード解析ツール**

`pycodestyle`
- `E` と `W` 系エラー
- 役割：**コードスタイル（PEP8）違反の検出。**

`pyflakes `
- `F` 系エラー
- 役割：**実行前に発生しうるバグを検出**


`mccabe`
- `C` 系エラー
- 役割：**コードの複雑度のチェック**

| 系統       | よく出る    |
| -------- | ------- |
| **F4xx** | 未使用・未定義 |
| **F821** | 未定義     |
| **E30x** | 空行      |
| **E501** | 行長      |


※Python実践レシピ:コーディング規約

### このコードに対して、「自動でコードを整形してスペースやインデントを修正するツール」として正しいのはどれか。


```python
def add(a,b):
  return a+b
```

```python
1. Pyflakes
2. PEP8
3. Black
4. Flake8
```

**回答**
`Flake8`

**正解**
`Black`

**解説**
- Black は「**自動でコード整形**」するツール。

- Flake8 は「**コードチェック**」するツールで**自動修正はしない。**

- PEP8 は **Python コードスタイルの規約でツールではない。**

- Pyflakes は**実行前バグ（未使用変数や未定義変数など）を検出**するだけ。

※Python実践レシピ:コーディング規約

### `@contextlib.contextmanager` の役割として正しいものはどれか。

```python
1. with 文の中で例外が発生した場合に自動的に握りつぶす
2. クラスのメソッドに自動的に __enter__ と __exit__ を付与する
3. ファイル操作やネットワーク通信を高速化するための最適化ツール
4. with 文で使えるコンテキストマネージャを、関数だけで簡単に定義できるようにする
```

**回答**
クラスのメソッドに自動的に `__enter__` と `__exit__` を付与する

**正解**
`with` 文で使えるコンテキストマネージャを、**関数だけで簡単に定義できるようにする**

**解説**
- `@contextlib.contextmanager` は、関数にデコレーターを付けるだけで **`with` 文用のコンテキストマネージャを作れるようにするもの**です。
- `yield` の前が `__enter__` の処理、`yield` の後が `__exit__` の処理になります。

※Python実践レシピ:Pythonの言語仕様

### 次のコードを実行した場合、出力されるものはどれか。
```python
try:
    x = int("abc")
except ZeroDivisionError:
    print("ゼロ除算エラー")
except ValueError:
    print("値エラー")
except Exception:
    print("一般的な例外")
```

```python
1. エラーが出るため何も出力されない
2. ゼロ除算エラー
3. 一般的な例外
4. 値エラー
```

**回答**
一般的な例外

**正解**
値エラー

**解説**
- `int()`は文字列や数値を整数に変換する関数。
- `"abc"` は数字ではなく文字列なので、整数として解釈できない。
- このとき Python は**型が不正であるため `ValueError` を発生させる。**

- `"abc"` の 型 は `str`
  - `int()` は **`str` を受け取れる**
- でも `"abc"` は **数値として解釈できない**

- つまり：
  - 型が違う → `TypeError`
  - 値が不正 → `ValueError`

※Python実践レシピ:Pythonの言語仕様

### 次のコードを実行したときの出力として正しいものはどれか。


```python
numbers = [1, 2, 3, 4, 5]

mapped = map(lambda x: x*2, numbers)

filtered = filter(lambda x: x % 2 == 0, numbers)

print(list(mapped))
print(list(filtered))
```

```python
1. 
[1, 2, 3, 4, 5]
[1, 3, 5]

2. 
[2, 4, 6, 8, 10]
[2, 4]

3. 
[1, 2, 3, 4, 5]
[2, 4]

4. 
[2, 4, 6, 8, 10]
[1, 3, 5]
```

**回答**
```python
[2, 4, 6, 8, 10]
[1, 3, 5]
```

**正解**
```python
[2, 4, 6, 8, 10]
[2, 4]
```

**解説**
`map()`
- 目的：**イテラブルの 各要素に関数を適用して変換** する
- 書き方：`map(function, iterable)`
  - `function`：各要素に適用する関数
  - `iterable`：リスト、タプル、文字列など

`filter()`
- 目的：イテラブルの **条件を満たす要素だけを取り出す**
- 書き方：`filter(function, iterable)`
- `function` は **True/False を返す関数**
- **True の要素だけが結果に残る**

※Python実践レシピ:コーディング規約

### 次のコードを実行すると出力はどうなるか。


```python
def greet(name, age, city):
    print(f"{name}, {age}, from {city}")

args = ("Alice", 30)
kwargs = {"city": "Tokyo"}

greet(*args, **kwargs)
```


```python
1. Alice, 30, from Tokyo
2.('Alice', 30) {'city': 'Tokyo'}
3.Alice, 30, from {'city': 'Tokyo'}
4. 実行時にエラーが発生する
```

**回答**
`Alice, 30, from {'city': 'Tokyo'}`

**正解**
`Alice, 30, from Tokyo`

**解説**
- `*args` は タプルやリストを展開して、**位置引数として渡す**

- `**kwargs` は 辞書を展開して、**キーワード引数として渡す**
  - `city=Tokyo`として渡しているので関数の`city`の値は`Tokyo`になる

※Python実践レシピ:コーディング規約

### 次のコードを実行した場合の出力として正しいものはどれか。


```python
def mix(a, b, c):
    a += (1,)
    b += [1]
    c['x'] = 1
    return a, b, c

t = (0,)
l = [0]
d = {'y': 0}

result = mix(t, l, d)

print(result)
print(t, l, d)
```

```python
1. 
((0, 1), [0], {'y': 0})
(0,) [0] {'y': 0}

2. 
((0, 1), [0, 1], {'y': 0, 'x': 1})
(0,) [0, 1] {'y': 0, 'x': 1}

3. 
((0,), [0, 1], {'y': 0, 'x': 1})
(0,) [0] {'y': 0}

4. 
((0, 1), [0, 1], {'y': 0, 'x': 1})
(0, 1) [0, 1] {'y': 0, 'x': 1}
```

**回答**
```python
((0, 1), [0], {'y': 0})
(0,) [0] {'y': 0}
```

**正解**
```python
((0, 1), [0, 1], {'y': 0, 'x': 1})
(0,) [0, 1] {'y': 0, 'x': 1}
```

**解説**
- この問題の注意点は、**イミュータブルとミュータブルか**です。

**タプル　`a, t`**
- **タプルは 変更できない（イミュータブル）。**
- `a += (1,)` は実は **新しいタプル `(0,1)` を作って `a` に再代入 しているだけ。**
- **そのため、元の `t` は 変更されない。**



**リスト　`b, l`**
- **リストは 変更できる（ミュータブル）。**
- `+=` は**リスト自体を変更する操作**（b.extend([1]) と同じ）。
- つまり、`b` も `l` も **同じリストを指しているため**、**元の l も変更される。**



**辞書　`c, d`**
- **辞書も ミュータブル。**
- `c` は `d` と**同じ辞書を参照しているため、操作すると `d` も変更される。**

※Python実践レシピ:コーディング規約

### PEP8 命名規則において、モジュール名の表記方法として正しいものはどれか？

```python
1. data_processor
2. dataProcessor
3.DATA_PROCESSOR
4. DataProcessor
```

**回答**
`DataProcessor`

**正解**
`data_processor`

**解説**
- モジュール名とパッケージは、**lowercase**

※Python実践レシピ:コーディング規約

### PEP8 命名規則において、クラス名の表記方法として正しいものはどれか？

```python
1. employee_data
2. EmployeeData
3. employee-data
4.bemployeeData
```

**回答**
`employeeData`

**正解**
`EmployeeData`

**解説**
- クラス名は、**CamelCase**

※Python実践レシピ:コーディング規約

### 次の Python コードを実行するとどうなるか。正しい結果を 1つ選べ。

```python
def report(title, *items, **options):
    print("Title:", title)
    print("Items:", items)
    print("Options:", options)

report("Shopping List", "Apple", "Banana", urgent=True, owner="John")
```

```python
1. 
実行時エラーが発生する

2. 
Title: Shopping List
Items: ('Apple', 'Banana', {'urgent': True, 'owner': 'John'})
Options: {}

3. 
Title: Shopping List
Items: ('Apple', 'Banana')
Options: {'urgent': True, 'owner': 'John'}

4. 
Title: Shopping List
Items: ['Apple', 'Banana']
Options: {'urgent': True, 'owner': 'John'}
```

**回答**
実行時エラーが発生する


**正解**
```python
Title: Shopping List
Items: ('Apple', 'Banana')
Options: {'urgent': True, 'owner': 'John'}
```

**解説**

`*items`（可変長位置引数）
- `"Apple"` と `"Banana"` が **タプル `('Apple', 'Banana')` としてまとめられる。**


`**options`（可変長キーワード引数）
- `urgent=True` と `owner="John"` が辞書 **`{'urgent': True, 'owner': 'John'}` として渡される。**

※Python実践レシピ:コーディング規約

### Blackのオプション `--line-length` で、デフォルトの1行の最大文字数は何文字か

```python

1. 88

2. 76

3. 86

4. 79
```

**回答**
79

**正解**
88

**解説**
**■Blackの主要オプション**

- `--line-length`
  -  1 行の最大文字数を指定（**デフォルト 88**）

- `--check` 　　　
  - コードを整形せずに、整形が必要かどうかだけ確認

- `--diff`
  - 整形後の差分だけ表示（実際には書き換えない）

- `--exclude` 　
  - 整形対象からファイルやディレクトリを除外

- `--include` 　
  - 整形対象のファイルパターンを指定

**※PEP8 では 79文字 が推奨**
- Black は 可読性と実務上の現実的なライン を考えて **88文字 にしている**

※Python実践レシピ:コーディング規約

### 次のコードを Flake8 にかけた時、発生すると考えられるエラーコードはどれか。

```python
def add(a,b):
    return a+b
```

```python
1. F401
2. E231
3. W291
4. E302
```

**回答**
E302

**正解**
E231

**解説**
- `add(a,b)` の `a,b` の**カンマの後にスペースがない**ため、**E231: missing whitespace after ','** が発生する。

- E302 は**関数定義の前の空行不足（2 行必要）に関するもの** 
  - 今回はコードの最初なので該当しない

- W291 は行末の空白
- F401 は未使用の import

| エラーコード   | 用途・意味          | 例                        |
| -------- | -------------- | ------------------------ |
| **F401** | 未使用の import    | `import math` だけで使わない    |
| **F821** | 未定義の名前         | `print(x)` で `x` が未定義    |
| **F841** | 未使用の変数         | `x = 10` だけで使わない         |
| **E231** | カンマの後のスペース不足   | `a,b` → `a, b`           |
| **E302** | 関数・クラス定義前の空行不足 | `def f():` の前に空行がない      |
| **E305** | 関数・クラス定義後の空行不足 | 定義後に空行がない                |
| **E501** | 行が長すぎる         | PEP8 では79文字超え（Black は88） |
| **W291** | 行末の余計な空白       | `x = 10 `（末尾にスペース）       |

※Python実践レシピ:コーディング規約

### 次のうち、ジェネレータがメモリ上でどれだけのサイズを使っているか調べるための正しいコマンド はどれか。

```python
gen = (x**2 for x in range(1000))
```

```python
1. print(gen.__size__)
2. len(gen)
3. sys.getsizeof(gen)
4. gen.size()
```

**回答**
`print(gen.__size__)`

**正解**
`sys.getsizeof(gen)`

**解説**
`sys.getsizeof(gen)`
- `sys.getsizeof()` は**オブジェクトが メモリ上で占めているサイズ をバイト単位で返す**
- ジェネレータ本体のサイズを調べることができる
注意：生成される要素のサイズは含まれない

**※他選択肢について**

`len(gen)`

- ジェネレータは要素を順番に生成するだけで **長さ情報は持たない**

`gen.size()`
- ジェネレータには **`size()` メソッドは存在しない**
- 実行すると AttributeError になる



`gen.__size__`
- ジェネレータに **`__size__` 属性は存在しない**
- 実行すると AttributeError になる

**※注意点**
- `len(list(gen))`
  - これで**全要素をメモリに展開**し、ジェネレータの要素数を数えることはできます。
- ただ、ジェネレータは本来「遅延評価」で軽量なのに、`list(gen) `にすると **全要素がリストとしてメモリに展開される**
- 規模データや無限ジェネレータでは 危険／メモリ不足になる

※Python実践レシピ:コーディング規約

### 次の Python コードを実行すると、出力として正しいものはどれか。

```python
def add_item(item, lst=[]):
    lst.append(item)
    return lst

print(add_item("A"))
print(add_item("B"))
```

```python
1. 
['A']
['B']

2. 
A
B

3. 
['A']
['A', 'B']

4. 
A
A, B
```

**回答**
```python
['A']
['B']
```

**正解**
```python
['A']
['A', 'B']
```

**解説**
**■デフォルト引数の落とし穴**
- `lst=[]` というデフォルト値のリストは 関数定義時に一度だけ作られ、すべての呼び出しで共有される。

- **変更が残らないようにするには None を使う。**

```python
def add_item(item, lst=None):
    if lst is None:
        lst = []
    lst.append(item)
    return lst
```


※Python実践レシピ:コーディング規約
