## 13.1 CSVファイルを扱う csv
### CSVファイルの読み込みと書き込み
- csvモジュールの **`reader`** と **`writer`** は、CSV（Comma-Separated Values）**ファイルを扱う**ための中心的なオブジェクト。
- これらは、CSVファイルの読み書きを簡単かつ標準的な方法で行えるようにする。

**`csv.reader`**
- `csv.reader`は、CSVファイルや、CSV形式の**文字列を読み込むためのイテレータオブジェクト**
- これにより、CSVの1行1行を**リスト**として取得できる。
- **機能：**
  - **`csv.reader(csvfile, dialect='excel', **fmtparams)`** という形で使用する。
    - `csvfile`は、**`open()`** 関数で開かれたファイルオブジェクト。
    - `dialect`や`fmtparams`で、**区切り文字（delimiter）** や **引用符（quotechar）** などを細かく指定できる。
- **使い方：**
  - **`reader`** オブジェクトはイテレータなのでforループで1行ずつ処理するのが一般的。
  - 各行は、**文字列のリスト**として返される

**`csv.writer`**
- `csv.writer`は、CSVファイルにデータを**書き込む**ための**オブジェクト**。
    - **リストやタプルなどのデータ**を、CSV形式の文字列としてファイルに書き込む。
- **機能：**
    - **`csv.writer(csvfile, dialect='excel', **fmtparams)`** という形で使用する。
    - `csvfile`は、`open()`関数で開かれたファイルオブジェクト
    - `reader`と同様に、`dialect`や`fmtparams`で書き込み形式をカスタマイズできる。
- **使い方：**
    - **`writer.writerow(row)`** : **1行（リストやタプル）** をCSVファイルに書き込む。
    - **`writer.writerows(rows)`** : **複数の行（リストのリスト）**を
        一度にCSVファイルに書き込む。

`csv`モジュールでは、CSVファイルの書式（区切り文字、引用符など）を細かく制御するために、**書式化パラメーター**と **`Dialect`** クラスが用いられる。

**`excel`**
- これが`csv`モジュールの**デフォルトの`Dialect`**
- Microsoft Excelが生成するCSVファイルの一般的な形式に合わせている。
    - **`delimiter`**: `','`（カンマ）
    - **`quotechar`**: `'"'`（ダブルクォーテーション）
    - **`lineterminator`**: `'\r\n'`（CRLF）

**`excel-tab`**
- Excelがタブ区切りのテキストファイルとして保存する場合の形式。
  - **`delimiter`**: `'\t'`（タブ）
- それ以外の設定は`excel`とほぼ同じ。

**`unix`**
- Unix系のシステムで使われることが多い、よりシンプルな形式。
  - **`delimiter`**: `','`（カンマ）
  - **`quotechar`**: `'"'`（ダブルクォーテーション）
  - **`lineterminator`**: `'\n'`（LF）
  - **`quoting`**: `QUOTE_ALL`（すべてのセルを引用符で囲む）
- これらの`Dialect`は、`reader`や`writer`の **`dialect`引数に指定**することで利用できる

**`Dialect`クラスの属性**
- `Dialect`クラスは、上記の書式化パラメーターをひとまとめにしたもの。
  - 特定のCSV形式を定義し、それを再利用可能にする
- `csv`モジュールには、いくつかの組み込み`Dialect`（`'excel'`、`'excel-tab'`など）があるが、**独自の`Dialect`を定義することも可能**
- `Dialect`クラスの主な属性は、**書式化パラメーターとほぼ同じ**

| 属性名 | 説明 |
| --- | --- |
| `delimiter` | フィールド（セル）を区切る文字。 |
| `quotechar` | フィールド内の特殊文字を囲む文字。 |
| `lineterminator` | 書き込み時に使用する行末文字。 |
| `skipinitialspace` | 区切り文字の直後の空白文字を無視するかどうか。 |

**`Dialect`の使い方**
- `Dialect`は、`csv.reader`や`csv.writer`に`dialect`引数として渡すことで使用できる。
  - これにより、個々のパラメーターを毎回指定する手間が省ける

### 辞書データを用いたCSVファイルの読み込みと書き込み

- `csv`モジュールの **`DictReader`** と **`DictWriter`** は、**CSVファイルを辞書（Dictionary）として扱う**ためのクラス
  - これにより、各行のデータをキーと値のペアとして直感的に操作でき、可読性が向上する

**`csv.DictReader`**
- `DictReader`はCSVファイルを読み込む際に、各行を**キーと値のペア**を持つ**辞書**として扱う

- **機能：**
  - CSVファイルの最初の行を**ヘッダー**として自動的に認識し、その**ヘッダー名を辞書のキー**として使用する

- **使い方：**
    - **`DictReader(csvfile, fieldnames=None, restkey=None, restval=None, **fmtparams)`**　という形で使用する。
        - `csvfile`はファイルオブジェクト。
        - `fieldnames`引数を指定しない場合、**CSVファイルの最初の行**が**自動的にキー**として使われる。
    - `for`ループで`DictReader`オブジェクトをイテレートすると、**各行が辞書**として返される。
- **`DictReader`** を使えば、`row[0]`のようにインデックスでアクセスする代わりに、`row['name']`のように**ヘッダー名でアクセスできる**ため、コードがより分かりやすくなる

**`csv.DictWriter`**
- **`DictWriter`** は、**辞書データ**をCSVファイルに**書き込む**ためのクラス。
- **機能：** **辞書（Dictionary）のキーをヘッダー**として使用し、そのキーに**対応する値をCSVのセル**として書き込む

- **使い方：**
  - **`DictWriter(csvfile, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds)`** という形で使用する。
    - `csvfile`はファイルオブジェクト
    - **`fieldnames`引数が必須**であり、これは**CSVのヘッダーとして使用するキーのリスト**
        - このリストの順番で列が並ぶ。

**`DictWriter`** には、以下の2つの主要な書き込みメソッドがある
1. **`DictWriter.writerow(rowdict)`：** 
- **1つの辞書を1行**として書き込む。
- 辞書に **`fieldnames`で指定されていないキー** があっても、**デフォルトでは無視**される
2. **`DictWriter.writerows(rowdicts)`：**
- 辞書のリストを**一度に複数行**書き込む。

**`DictWriter.writeheader()`**
- `writeheader()`は、`DictWriter`オブジェクトに特有の便利なメソッド。
- **機能：**`DictWriter`の初期化時に指定した **`fieldnames`のリスト** を、CSVファイルの**ヘッダー行**として書き込む。
- **使い方：**
  - データを書き込む前に、このメソッドを一度だけ呼び出す
- **`writeheader()`** を使うことで、ヘッダーを手動で書く必要がなくなり、コードがより簡潔になる

**csv_module.py**

## 13.2 JSONを扱う `json`

### JSONのエンコードとデコード

- `json`モジュールの **`dumps`** と **`loads`** は、**Pythonのデータ構造（辞書、リストなど）とJSON形式の文字列を相互に変換**するための関数。
- これらは、データをファイルに保存したり、ネットワーク経由で送受信したりする際に不可欠な役割を果たす

**`json.dumps()`（ダンプス）**

- `dumps`は、**Pythonのデータ（オブジェクト）をJSON形式の文字列に変換**する。
  - このプロセスは「**シリアライズ**」と呼ばれる
- **機能：** 
  - **辞書やリスト**などのPythonオブジェクトを受け取り、**JSONの構文に準拠した文字列として返す**
- **使い方：** 
  - **`json.dumps(obj, **kwargs)`** という形で使用する
    - **`obj`**：変換したいPythonのオブジェクト
    - **`kwargs`**：変換の書式を制御するための引数
      - `indent`や`sort_keys`などがよく使われる

**`json.loads()`（ロッズ）**
- `loads`は、`dumps`の逆の操作を行う
- **JSON形式の文字列をPythonのデータに変換**する
  - このプロセスは「**デシリアライズ**」と呼ばれる
- **機能：**
  - **JSON形式の文字列**を受け取り、対応するPythonのオブジェクト（**辞書やリストなど）として返す**
- **使い方：**
  - `json.loads(s, **kwargs)`という形で使用する。
    - `s`: 変換したいJSON形式の文字列
    - `**kwargs`: デコードの動作をカスタマイズするためのオプション

**`**kwargs`** のオプションについて
1. **`object_hook`**
- 用途: JSONオブジェクト（辞書）が**デコードされる際に呼び出される関数を指定**
- これを使って、デコードされたPython辞書を**別の型のオブジェクトに変換**したり、カスタム処理を施したりできる

2. **`parse_float`, `parse_int`, `parse_constant`**
- 用途: JSON内の**数値や定数**を、**標準のPython型（float, int）とは異なる型で解析したい**場合に、**対応する関数を指定**

| **引数** | **説明** |
| --- | --- |
| **`parse_float`** | JSONの浮動小数点数を解析する関数を指定（例: `decimal.Decimal` で解析） |
| **`parse_int`** | JSONの整数を解析する関数を指定|
| **`parse_constant`** | JSONの定数（`"-Infinity"`, `"Infinity"`, `"NaN"`）を解析する関数を指定 |

3. **`object_pairs_hook`**
- 用途: JSONオブジェクトがデコードされる際に、**キーと値のペアのリストとして渡され**、それを基に**Pythonオブジェクトを構築する関数を指定**
  - `object_hook` よりも優先される
- **JSON内のキーの順序を保持したい場合**などに便利（Python 3.7+ では通常の辞書でも挿入順序が保持されるが、古いバージョンや特殊な用途で使用）。

**`dumps`と`loads`の使い分け**

|  | **`json.dumps()`** | **`json.loads()`** |
| --- | --- | --- |
| **入力** | Pythonのオブジェクト（辞書、リストなど） | JSON形式の文字列 |
| **出力** | JSON形式の文字列 | Pythonのオブジェクト |
| **目的** | Pythonのデータを**外部形式（文字列）に変換 | 外部形式（文字列）をPythonのデータ**に戻す |
| **比喩** | 荷物を箱に**詰める**（データを文字列化） | 箱から荷物を**出す**（文字列をデータ化） |
- これらの関数は、JSONデータをメモリ内で扱う際に特に便利。

**例：json_module.py**

### JSONのエンコードとデコード（ファイルオブジェクト）

- `json`モジュールの **`load`** と **`dump`** は、**JSONデータをファイルとやり取りする**ための関数
- `dumps`と`loads`が**文字列を扱う**のに対し、これらは**ファイルオブジェクトを直接扱う**

**`json.load()`（ロード）**
- `load`は、**JSONファイルからデータを読み込み、Pythonのデータ構造に変換する**
- **機能：**
  - **ファイルオブジェクト**を受け取り、その中にある**JSON形式のデータ**を**デシリアライズ**（**Pythonオブジェクトに変換**）する
- **使い方：** 
  - **`json.load(fp)`** という形で使用する。
    - `fp`は、`open()`関数で**読み込みモードで開かれたファイルオブジェクト**。

**`json.dump()`（ダンプ）**
- `dump`は、**Pythonのデータ構造をJSONファイルに書き込む**。
- **機能：**
  - Pythonのオブジェクトとファイルオブジェクトを受け取り、**オブジェクトをJSON形式の文字列にシリアライズ**して**ファイルに書き込む**
- **使い方：** 
  - **`json.dump(obj, fp)`** という形で使用する
    - `obj` ：書き込みたいPythonのオブジェクト。
    - `fp`：`open()`関数で書き込みモードで開かれたファイルオブジェクト。
    - `indent`を指定することで、人間が読みやすいように整形して書き込むことも可能

#### **`dump`, `load` と `dumps`, `loads` の違い**
- `dump`と`load`、そして`dumps`と`loads`は機能が似ているが、大きな違いは**データのやり取り先**。

|  | `dump`/`load` | `dumps`/`loads` |
| --- | --- | --- |
| **対象** | **ファイル**オブジェクト (`fp`) | **文字列** (`s`) |
| **主な用途** | データをファイルに**保存・読み込み**する | データをメモリ上で文字列に**変換**する |
- `dump`と`load`は**ファイル I/O**を行うのに対し、
- `dumps`と`loads`は純粋な**文字列操作**を行う

**`json`モジュールを使って、Pythonのデータ型とJSON形式のデータ型を相互に変換する際の対応表**

| **Pythonのデータ型** | **JSONのデータ型** |
| --- | --- |
| `dict` (辞書) | `object` (オブジェクト) |
| `list`, `tuple` (リスト, タプル) | `array` (配列) |
| `str` (文字列) | `string` (文字列) |
| `int`, `float` (整数, 浮動小数) | `number` (数値) |
| `True` | `true` |
| `False` | `false` |
| `None` | `null` |

- この変換は、**エンコード（Python → JSON）** と**デコード（JSON → Python）** の2つのプロセスで行われる

**例：json_module2.py**