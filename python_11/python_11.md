## 11.1 ファイルパス操作を直感的に行う **`pathlib`**

- `pathlib` モジュールは、Python の標準ライブラリに含まれており、ファイルシステムのパスをオブジェクト指向で扱えるようにするモジュール

### クラス構成

| **クラス名** | **継承元** | **実ファイル操作** | **OS依存** | **役割・特徴** |
| --- | --- | --- | --- | --- |
| `PurePath` | なし | ❌ | ❌ | 抽象的なパス操作の基底クラス（OS非依存） |
| `PurePosixPath` | `PurePath` | ❌ | ✅ | UNIX系（Linux/macOS）向け抽象パス |
| `PureWindowsPath` | `PurePath` | ❌ | ✅ | Windows向け抽象パス |
| `Path` | `PurePath` | ✅ | ✅ | 実ファイル操作が可能な汎用パスクラス。OSによって自動で `PosixPath` または `WindowsPath` に切り替わる |
| `PosixPath` | `Path` | ✅ | ✅ | UNIX系で使われる実パスクラス |
| `WindowsPath` | `Path` | ✅ | ✅ | Windowsで使われる実パスクラス |

### 純粋パスを扱う `PurePath`

- `PurePath` クラスは `pathlib` モジュールの中でも「**パス操作専用**」のクラスで、**ファイルの中身に触らず、安全にパスをいじりたいとき**に使用
- **パスの文字列（例：`"folder/file.txt"`）をオブジェクトとして扱うクラス**
- ファイルの**実在チェックや読み書きはできない**
- ファイルシステムにアクセスしないので**安全＆高速**
- 複雑なパス操作（結合、親ディレクトリの取得など）を、文字列連結より**正確に簡潔に**できる

| **特徴** | **説明** |
| --- | --- |
| パスをオブジェクトとして扱う | `"a/b/c.txt"` → `PurePath("a", "b", "c.txt")` |
| ファイル操作NG | `exists()` や `open()` は使えない |
| 高速・安全 | 実際のファイルにアクセスしないので副作用なし |
| OS非依存/依存の派生あり | `PurePosixPath`（Linux/mac）`PureWindowsPath`（Windows） |

**派生クラス（用途に応じて選ぶ）**

| クラス名 | 主な用途 |
| --- | --- |
| `PurePath` | OSに応じて自動で派生クラスを選択（通常これでOK） |
| `PurePosixPath` | UNIX/Linux/macOS 向け |
| `PureWindowsPath` | Windows 向け |

**`PurePath`クラスのインスタンス変数**

| プロパティ名 | 説明（返り値の型） | 例（パス: `C:/Users/example/file.tar.gz`） |
| --- | --- | --- |
| `parts` | パスをすべての部分に分割したタプル（`tuple`） | `('C:\\', 'Users', 'example', 'file.tar.gz')` |
| `drive` | ドライブ文字（Windowsのみ）（`str`） | `'C:'` |
| `root` | ルートディレクトリの部分（`str`） | `'\\'`（Windows） or `'/'`（UNIX） |
| `anchor` | `drive + root`（`str`） | `'C:\\'` |
| `parents` | 親ディレクトリのリスト（`PurePath` のシーケンス） | `['C:/Users/example', 'C:/Users', 'C:/']` |
| `parent` | すぐ上の親ディレクトリ（`PurePath`） | `C:/Users/example` |
| `name` | ファイル名（拡張子込み）（`str`） | `'file.tar.gz'` |
| `suffix` | 最後の拡張子（`str`） | `'.gz'` |
| `suffixes` | すべての拡張子をリストで（`list[str]`） | `['.tar', '.gz']` |
| `stem` | 拡張子を除いたファイル名（`str`） | `'file.tar'` |

**`PurePath`クラスのメソッド**

| メソッド名 | 説明 | 戻り値の型 | 使用例（パス例） |
| --- | --- | --- | --- |
| **`is_absolute()`** | パスが絶対パスなら `True` を返す | `bool` | `PurePath('/home/user').is_absolute()` → `True` |
| **`is_relative_to()`** | 指定したパスに対して相対パスかどうかをチェック（Python 3.9〜） | `bool` | `PurePath('a/b/c').is_relative_to('a')` → `True` |
| **`with_name(name)`** | ファイル名（最後の部分）を別名に置き換える | `PurePath` | `PurePath('dir/file.txt').with_name('new.txt')` → `'dir/new.txt'` |
| **`with_stem(stem)`** | 拡張子を残したままファイル名部分だけ変更（Python 3.9〜） | `PurePath` | `'file.txt' → new.txt` |
| **`with_suffix(suffix)`** | 拡張子を新しいものに置き換える。空文字で削除も可能 | `PurePath` | `PurePath('file.txt').with_suffix('.md')` → `'file.md'` |
  
**PurePath_class.py**

### 具象パスを扱う `Path`

- `pathlib` モジュールのクラスで、**パス操作 + ファイル/ディレクトリの実操作**ができる。
- **`PurePath` を継承**しており、パス操作の便利さに加えて、**実ファイルの存在確認・作成・削除・読み書きなどが可能**。
- **オブジェクト指向で直感的にファイル操作ができる**のが最大の利点。

**Pathクラスのメソッド**

| **メソッド** | **説明** | **使用例** |
| --- | --- | --- |
| **`Path.cwd()`** | 現在の作業ディレクトリを取得（クラスメソッド） | `Path.cwd()` |
| **`Path.home()`** | ユーザーのホームディレクトリを取得 | `Path.home()` |
| **`path.stat()`** | ファイルの情報（サイズ・更新日時など）を取得 | `p.stat()` |
| **`path.chmod(mode)`** | パーミッション（アクセス権）を変更 | `p.chmod(0o755)` |
| **`path.exists()`** | ファイルやディレクトリが存在するか | `p.exists()` |
| **`path.glob(pattern)`** | ワイルドカードでマッチするファイル一覧を取得 | `p.glob("*.txt")` |
| **`path.is_dir()`** | ディレクトリかどうか | `p.is_dir()` |
| **`path.is_file()`** | ファイルかどうか | `p.is_file()` |
| **`path.iterdir()`** | ディレクトリの中身（直下のファイル・ディレクトリ）を取得 | `for f in p.iterdir(): ...` |
| **`path.mkdir()`** | ディレクトリを作成 | `p.mkdir()` |
| **`path.open()`** | ファイルを開く（読み書き可能） | `p.open('r')` |
| **`path.read_text()`** | テキストファイルを読み込む | `p.read_text()` |
| **`path.write_text(data)`** | テキストファイルに書き込む | `p.write_text("Hello!")` |
| **`path.rename(new_path)`** | ファイル/ディレクトリをリネーム | `p.rename('new.txt')` |
| **`path.resolve()`** | 絶対パスを取得（シンボリックリンクも解決） | `p.resolve()` |
| **`path.rmdir()`** | 空のディレクトリを削除 | `p.rmdir()` |
| **`path.touch()`** | 空のファイルを作成（更新） | `p.touch()` |
| **`path.unlink()`** | ファイルを削除 | `p.unlink()` |

**Path_class.py**

### `pathlib`：ちょっと役立つ周辺知識

**`path-like`オブジェクト**
- **path‑like オブジェクト（path‑like object）は、`__fspath__()` メソッドを実装しているオブジェクト**
- **`open()` や `os`, `shutil` などの標準ライブラリ関数が`str`（文字列）ではなく、これらを受け入れて動作することができる**形式
- たとえば `pathlib.Path` オブジェクトを直接 `open()` に渡しても正しく動作する
    
**各モジュール・メソッド**
    
| モジュール／関数 | 説明 |
| --- | --- |
| **`open()`** | ファイルを開いて読み書き用のファイルオブジェクトを返す。path‑like 対応。 |
| **`configparser`** | `.ini`形式の設定ファイルの読み書きに使う標準ライブラリ。 |
| **`zipfile`** | ZIP形式の圧縮／解凍を扱うライブラリ。 |
| **`sqlite3`** | 組み込み軽量データベース SQLite を操作できるモジュール。 |
| **`shutil`** | ファイル／ディレクトリのコピー、移動、削除など高水準操作を提供。 |
| **`os`** | OS依存の操作（環境変数、プロセス、ファイル操作など）を提供。 |
| **`os.path`** | ファイルパスの結合や分解など、文字列ベースのパス操作関数を提供。 |

**例：path-like_obj.py**

## 11.2 一時的なファイルやディレクトリを作成する `tempfile`

- **`tempfile`** は、**一時的なファイルやディレクトリを作成**するためのPythonの標準ライブラリ
- これらのファイルやディレクトリは、プログラムの実行中に一時的にデータを保存するために使用される。
- 通常は**プログラムの終了時や、明示的に閉じられたときに自動的に削除**される
    - これにより、手動でクリーンアップする必要がなくなり、ディスク上に不要なファイルが残るのを防げる。
- `tempfile`モジュールは、用途に応じていくつかの高レベルなオブジェクトを提供している
    - これらはコンテキストマネージャとして使うのが一般的で、`with`文を使うことで、ブロックを抜けたときに自動的にファイルやディレクトリが閉じられ、削除される。

### 一時ファイルを作成する

**`TemporaryFile`**

- `TemporaryFile`は、一時的なファイルを安全に作成する最も一般的な方法の一つ。
- このファイルはディスク上に作成されるが、**ファイルシステム上で名前を持たない**ため、他のプロセスからアクセスされる心配がない。
- **特徴**
    - **名前を持たない：`TemporaryFile`** は、ファイルシステム上では名前がないため、`os.path`などの通常のパス操作ではアクセスできない
        - この性質により、セキュリティが向上し、他のプロセスが誤ってファイルにアクセスするのを防ぐ
    - **自動削除：**`with`文（コンテキストマネージャ）を使用すると、ブロックを抜けたときにファイルが自動的に閉じられ、**ディスクから完全に削除**される。
        - これにより、プログラム終了後のクリーンアップ作業が不要になる。
    - **ファイルハンドル：** `TemporaryFile`は、ファイルオブジェクト（ファイルハンドル）を返す。
        - このハンドルを使って、通常のファイルと同様に読み書きができる。

**`TemporaryFile`の利点**
- **シンプルさ**: 一時ファイルの作成と削除をPythonがすべて自動で行ってくれるため、開発者はクリーンアップの心配をする必要がない。
- **安全性**: ファイルに名前がないため、外部のプロセスから偶発的にアクセスされたり、悪意のある攻撃を受けたりするリスクが軽減される。
- **ディスクスペースの管理**: 一時ファイルはプログラムの実行中のみ存在するため、ディスクスペースを効率的に利用できる。

**`NamedTemporaryFile`**

- **`NamedTemporaryFile`**は、ファイルシステム上で**名前を持つ**一時ファイルを安全に作成するためのPythonの便利なオブジェクト。
    - このオブジェクトを使うと、他のプログラムやプロセスにファイルパスを渡して、一時ファイルにアクセスさせることができる。

**`delete=False` でファイルを手動で削除する例**
- 特定の状況では、プログラムの終了後も一時ファイルを残しておきたい場合がある。
- その場合は、**`delete=False`オプション** を指定する。
  - ファイルは自動では削除されないため、**手動で削除する責任**が開発者にある

- **`TemporaryFile`と`NamedTemporaryFile`の違い**
    - `tempfile`には、一時ファイルに名前を付ける`NamedTemporaryFile`もある

|  | `TemporaryFile` | `NamedTemporaryFile` |
| --- | --- | --- |
| **名前の有無** | 名前なし | 一意な名前を持つ |
| **ファイル名** | `fp.name`属性は利用不可 | `fp.name`属性で取得可能 |
| **主な用途** | プロセス内での一時データ保存 | 他のプロセスとパスを共有する場合 |
| **クリーンアップ** | 自動（閉じられた時） | デフォルトで自動（閉じられた時） |

**TemporaryFile_module.py**

### 一時ディレクトリを作成する

**`tempfile.TemporaryDirectory`**
- `tempfile.TemporaryDirectory`は、一時的なディレクトリを作成し、管理するためのPythonの便利なクラス。
- これは**コンテキストマネージャ**として設計されており、`with`文と組み合わせて使うことで、ディレクトリとその中身を自動的に作成・削除する機能を提供する。

- **特徴**
    - **自動クリーンアップ：** `with`ブロックを抜けると、`TemporaryDirectory`は自動的にディレクトリと、その中にある**すべてのファイルやサブディレクトリを再帰的に削除**する。
        - これにより、手動でクリーンアップする手間が省け、ディスクに不要なファイルが残るのを防ぐ。
    - **一意な名前：** 作成されるディレクトリは一意な名前を持ち、他のディレクトリと衝突する心配がない。
    - **簡単な利用：** コンテキストマネージャとして使うため、ファイルの作成から削除までのライフサイクル管理が非常にシンプルになる。

**※注意点**
- `with`文を使わずに`TemporaryDirectory()`を直接インスタンス化した場合、クリーンアップは自動で行われない。
    - `cleanup()`メソッドを手動で呼び出す必要がある
**TemporaryDirectory_module.py**

## 11.3 高レベルなファイル操作を行う `shutil`

### ファイルをコピーする

**`shutil`**
- **`shutil`**　モジュールは、ファイルのコピーや移動、削除など、高レベルなファイル操作を行うためのPythonの標準ライブラリ。
    - 特にファイルのコピーに関しては目的や必要な機能に応じて複数の関数が提供されている

**`shutil.copyfile(src, dst)`**
- `copyfile()`は、**ファイルのデータのみ**をコピーする最も基本的な関数
- **機能**:：`src`（ソース）ファイルを`dst`（デスティネーション）にコピーする。
- **特徴：**
  - **`dst`はファイル名**でなければならない。
    - ディレクトリ名を指定するとエラーになる。
  - **ファイルのパーミッション（権限）やメタデータ（作成日時、更新日時など）は
        コピーされない。**　
    - `src`と`dst`が同じファイルを参照している場合もエラーになる。
  - **生のデータ**だけをコピーしたい場合に最適。

**`shutil.copy(src, dst)`**
- `copy()`は、`copyfile()`の機能に加えて、**ファイルのパーミッションもコピー**する。
- **機能：**`src`ファイルを`dst`にコピーし、`src`のパーミッションも`dst`に設定する。
- **特徴：**
  - `dst`がディレクトリの場合、`src`ファイルは`dst`ディレクトリ内に同じファイル名でコピーされる。
  - **パーミッション（読み取り、書き込み、実行権限）を保持**したい場合に便利。
  - `copyfile()`より多くの情報をコピーするが、
        メタデータ（タイムスタンプなど）はコピーしない。

**`shutil.copy2(src, dst)`**
  - `copy2()`は、`copy()`の機能に加えて、**ファイルメタデータも完全にコピー**する。
  - **機能：**`src`ファイルを`dst`にコピーし、パーミッションと**すべてのメタデータ**（作成日時、更新日時など）を保持する。
  - **特徴：**
    - `shutil`モジュールの中で、最も**完全なファイルコピー**を行う関数。
    - **タイムスタンプやその他のメタデータを保持**する必要がある場合にこの関数を使うべき。
  
**`shutil.copymode(src, dst)`**
- `copymode()`は、**ファイルのパーミッションのみ**をコピーする。
- **機能：**`src`ファイルのパーミッション情報を`dst`ファイルに適用する。
- **特徴：**
    - ファイルの内容は変更しない。
    - 既に存在するファイルのパーミッションを更新したい場合に有用。

**`shutil.copystat(src, dst)`**
- `copystat()`は、**ファイルのメタデータ（タイムスタンプなど）のみ**をコピーする。
- **機能：** `src`ファイルのメタデータ（パーミッション、作成日時、更新日時など）を`dst`ファイルに適用する。
- **特徴：**
  - ファイルの内容は変更しない。
  - `copymode()`よりも多くのメタデータをコピーする。

| 関数名 | データ | パーミッション | メタデータ |
| --- | --- | --- | --- |
| `copyfile()` | ✅ | ❌ | ❌ |
| `copy()` | ✅ | ✅ | ❌ |
| `copy2()` | ✅ | ✅ | ✅ |
| `copymode()` | ❌ | ✅ | ❌ |
| `copystat()` | ❌ | ✅ | ✅ |

**shutil_module.py**

### 再帰的にディレクトリやファイルを操作する

**`shutil.rmtree(path)`**
- `rmtree()`は、**ディレクトリツリー全体を再帰的に削除する**。
  - これは、`os.rmdir()`が**空のディレクトリしか削除できない**のに対し、非常に強力で危険な関数。
- **機能：** 指定した`path`にあるディレクトリと、その中にあるすべてのファイル、サブディレクトリを**まとめて削除**する
- **特徴：**
  - 削除処理は元に戻せないため、使用には**十分な注意が必要**。
  - 権限エラーが発生した場合は、`onerror`引数にエラーハンドラ関数を渡して処理をカスタマイズできる。
  - `ignore_errors=True`を設定すると、エラーを無視して削除を続行する。

**`shutil.move(src, dst)`**
- `move()`は、ファイルまたはディレクトリを**移動する**。
- **機能：**`src`（ソース）を`dst`（デスティネーション）に移動する。
- **特徴：**
  - `src`がファイル、`dst`がディレクトリの場合、ファイルは`dst`ディレクトリ内に移動する。
  - `src`がディレクトリ、`dst`が既存のディレクトリの場合、`src`ディレクトリは`dst`内に移動。
  - `os.rename()`と同様に、可能な限りOSのrename機能を使用するため、非常に高速。
  - ただし、異なるファイルシステム間での移動の場合、コピーと削除の処理が行われる。

**`shutil.copytree(src, dst)`**
- `copytree()`は、**ディレクトリツリー全体を再帰的にコピー**する。
- **機能：**`src`ディレクトリとその中のすべての内容を`dst`にコピーする。
- **特徴：**
    - `dst`は**存在しないディレクトリ**でなければならない
        - 既に存在する場合はエラーになる
    - ファイルの**パーミッションやメタデータはデフォルトでコピー**される（`copy2()`の挙動に似てる）。
    - シンボリックリンクをどう扱うか（コピーするか、リンク先をコピーするか）を　**`symlinks`**　引数で制御できる
    - エラー処理や無視するファイル・ディレクトリの指定も可能

**shutil_module2.py**